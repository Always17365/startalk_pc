// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_message_2eproto();
void protobuf_AssignDesc_message_2eproto();
void protobuf_ShutdownFile_message_2eproto();

class MessageKeyValue;
class StringHeader;
class PackageLength;
class ProtoHeader;
class AuthMessage;
class WelcomeMessage;
class StreamBegin;
class StartTLS;
class ProceedTLS;
class StreamEnd;
class UserConnect;
class Capability;
class ResponseSucceeded;
class ResponseFailure;
class ProtoMessage;
class MessageBody;
class IQMessage;
class PresenceMessage;
class XmppMessage;

enum SignalType {
  SignalTypePresence = 1,
  SignalTypeIQ = 2,
  SignalTypeIQResponse = 3,
  SignalTypeSucceededResponse = 4,
  SignalTypeFailureResponse = 5,
  SignalTypeChat = 6,
  SignalTypeGroupChat = 7,
  SignalTypeNormal = 8,
  SignalTypeError = 9,
  SignalTypeTyping = 10,
  SignalTypeNote = 11,
  SignalTypeTransfor = 12,
  SignalTypeReadmark = 13,
  SignalTypeRevoke = 14,
  SignalTypeSubscription = 15,
  SignalTypeMState = 16,
  SignalTypeHeadline = 17,
  SignalTypeShareLocation = 20,
  SignalTypeHeartBeat = 30,
  SignalTypeAuth = 45,
  SignalTypeStreamBegin = 50,
  SignalTypeStreamEnd = 51,
  SignalTypeWelcome = 100,
  SignalTypeUserConnect = 101,
  SignalTypeChallenge = 102,
  SignalStartTLS = 106,
  SignalProceedTLS = 108,
  SignalTypeWebRtc = 110,
  SignalTypeCarbon = 128,
  SignalTypeConsult = 132,
  SignalTypeEncryption = 136,
  SignalTypeCollection = 140,
  SignalTypeTrans = 141,
  SignalTypeCustomize = 142
};
bool SignalType_IsValid(int value);
const SignalType SignalType_MIN = SignalTypePresence;
const SignalType SignalType_MAX = SignalTypeCustomize;
const int SignalType_ARRAYSIZE = SignalType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SignalType_descriptor();
inline const ::std::string& SignalType_Name(SignalType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SignalType_descriptor(), value);
}
inline bool SignalType_Parse(
    const ::std::string& name, SignalType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignalType>(
    SignalType_descriptor(), name, value);
}
enum ClientType {
  ClientTypeMac = 1,
  ClientTypeiOS = 2,
  ClientTypePC = 3,
  ClientTypeAndroid = 4,
  ClientTypeLinux = 5,
  ClientTypeWeb = 6
};
bool ClientType_IsValid(int value);
const ClientType ClientType_MIN = ClientTypeMac;
const ClientType ClientType_MAX = ClientTypeWeb;
const int ClientType_ARRAYSIZE = ClientType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientType_descriptor();
inline const ::std::string& ClientType_Name(ClientType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientType_descriptor(), value);
}
inline bool ClientType_Parse(
    const ::std::string& name, ClientType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientType>(
    ClientType_descriptor(), name, value);
}
enum MessageType {
  MessageTypePNote = -11,
  MessageTypeRevoke = -1,
  MessageTypeConsultRevoke = -2,
  MessageTypeText = 1,
  MessageTypeVoice = 2,
  MessageTypePhoto = 3,
  MessageTypePhotoBigIm = 4,
  MessageTypeFile = 5,
  MessageTypeTopic = 6,
  MessageTypeRichText = 7,
  MessageTypeActionRichText = 8,
  MessageTypeReply = 9,
  MessageTypeShock = 10,
  MessageTypeNote = 11,
  MessageTypeGroupAt = 12,
  MessageTypeMarkdown = 13,
  MessageTypeExtText = 14,
  MessageTypeGroupNotify = 15,
  MessageTypeLocalShare = 16,
  MessageTypeWebRTCAudio = 20,
  MessageTypeWebRTCVidio = 21,
  MessageTypeImageNew = 30,
  MessageTypeSmallVideo = 32,
  MessageTypeRobotAnswer = 47,
  MessageTypeSourceCode = 64,
  MessageTypeTime = 101,
  MessageTypeBurnAfterRead = 128,
  MessageTypeCardShare = 256,
  MessageTypeMeetingRemind = 257,
  MessageTypeWorkWorldAtRemind = 258,
  MessageTypeMedalRemind = 259,
  MessageTypeEncrypt = 404,
  MessageTypeActivity = 511,
  MessageTypeRedPack = 512,
  MessageTypeAA = 513,
  MessageTypeCommonTrdInfo = 666,
  MessageTypeCommonProductInfo = 888,
  MessageTypeTransChatToCustomer = 1001,
  MessageTypeTransChatToCustomer_Feedback = 1003,
  MessageTypeTransChatToCustomerService = 1002,
  MessageTypeTransChatToCustomerService_Feedback = 1004,
  MessageTypeRedPackInfo = 1024,
  MessageTypeAAInfo = 1025,
  MessageTypeConsult = 2001,
  MessageTypeConsultResult = 2002,
  MessageTypeGrabMenuVcard = 2003,
  MessageTypeGrabMenuResult = 2004,
  MessageTypeQCZhongbao = 2005,
  MessageTypeMicroTourGuide = 3001,
  MessageTypeProduct = 4096,
  WebRTC_MsgType_VideoMeeting = 5001,
  MessageTypeShareLocation = 8192,
  MessageTypeTransNormal = 10081,
  MessageTypeCustomize = 10082,
  WebRTC_MsgType_Live = 65501,
  WebRTC_MsgType_VideoCall = 65505,
  WebRTC_MsgType_AudioCall = 65506,
  WebRTC_MsgType_Video_Group = 65534,
  WebRTC_MsgType_Video = 65535,
  MessageTypeRobotQuestionList = 65536,
  MessageTypeRobotTurnToUser = 65537,
  MessageTypeRobotQuestionListNew = 65538,
  MessageTypeFlightRemind = 65550,
  MessageTypeCommonServiceCard = 65551,
  WebRTC_MsgType_Audio = 131072,
  MessageTypeNotice = 134217728,
  MessageTypeSystem = 268435456,
  MediaTypeSystemLY = 268435457
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = MessageTypePNote;
const MessageType MessageType_MAX = MediaTypeSystemLY;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum StringHeaderType {
  StringHeaderTypeChatId = 1,
  StringHeaderTypeChannelId = 2,
  StringHeaderTypeExtendInfo = 3,
  StringHeaderTypeBackupInfo = 4,
  StringHeaderTypeReadType = 5,
  StringHeaderTypeJid = 7,
  StringHeaderTypeRealJid = 8,
  StringHeaderTypeInviteJid = 9,
  StringHeaderTypeDeleleJid = 10,
  StringHeaderTypeNick = 12,
  StringHeaderTypeTitle = 16,
  StringHeaderTypePic = 18,
  StringHeaderTypeVersion = 20,
  StringHeaderTypeMethod = 22,
  StringHeaderTypeBody = 24,
  StringHeaderTypeAffiliation = 28,
  StringHeaderTypeType = 30,
  StringHeaderTypeResult = 32,
  StringHeaderTypeReason = 34,
  StringHeaderTypeRole = 36,
  StringHeaderTypeDomain = 38,
  StringHeaderTypeStatus = 40,
  StringHeaderTypeCode = 42,
  StringHeaderTypeCdata = 50,
  StringHeaderTypeTimeValue = 52,
  StringHeaderTypeKeyValue = 54,
  StringHeaderTypeName = 56,
  StringHeaderTypeHost = 58,
  StringHeaderTypeQuestion = 60,
  StringHeaderTypeAnswer = 62,
  StringHeaderTypeFriends = 64,
  StringHeaderTypeValue = 66,
  StringHeaderTypeMaskedUuser = 68,
  StringHeaderTypeKey = 70,
  StringHeaderTypeCarbon = 72,
  StringHeaderTypeMode = 76,
  StringForbiddenWords = 78
};
bool StringHeaderType_IsValid(int value);
const StringHeaderType StringHeaderType_MIN = StringHeaderTypeChatId;
const StringHeaderType StringHeaderType_MAX = StringForbiddenWords;
const int StringHeaderType_ARRAYSIZE = StringHeaderType_MAX + 1;

const ::google::protobuf::EnumDescriptor* StringHeaderType_descriptor();
inline const ::std::string& StringHeaderType_Name(StringHeaderType value) {
  return ::google::protobuf::internal::NameOfEnum(
    StringHeaderType_descriptor(), value);
}
inline bool StringHeaderType_Parse(
    const ::std::string& name, StringHeaderType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StringHeaderType>(
    StringHeaderType_descriptor(), name, value);
}
enum IQMessageKeyType {
  IQKeyBind = 1,
  IQKeyMucCreate = 2,
  IQKeyMucCreateV2 = 3,
  IQKeyMucInviteV2 = 4,
  IQKeyGetMucUser = 5,
  IQKeySetMucUser = 6,
  IQKeyDelMucUser = 7,
  IQKeyAddUserSubscribe = 8,
  IQKeyDelUserSubscribe = 9,
  IQKeyGetUserSubScribe = 10,
  IQKeyGetVerifyFriendOpt = 11,
  IQKeySetVerifyFriendOpt = 12,
  IQKeySetUserSubScribeV2 = 13,
  IQKeyGetUserSubScribeV2 = 14,
  IQKeyGetUserFriend = 16,
  IQKeyGetRequest = 17,
  IQKeyDelUserFriend = 18,
  IQKeyGetUserKey = 20,
  IQKeyGetUserMask = 22,
  IQKeySetUserMask = 24,
  IQKeyCancelUSerMask = 26,
  IQKeySetAdmin = 28,
  IQKeySetMember = 30,
  IQKeyCancelMember = 32,
  IQKeyGetUserMucs = 36,
  IQKeyDestroyMuc = 40,
  IQKeyPing = 50,
  IQKeyAddPush = 52,
  IQKeyCancelPush = 60,
  IQKeyResult = 80,
  IQKeyError = 90,
  IQKeyGetVUser = 92,
  IQKeyGetVUserRole = 94,
  IQKeyStartSession = 96,
  IQKeyEndSession = 98,
  IQKeySessionEvent = 99,
  IQKeyGetForbiddenWords = 100,
  IQKeySetForbiddenWords = 101
};
bool IQMessageKeyType_IsValid(int value);
const IQMessageKeyType IQMessageKeyType_MIN = IQKeyBind;
const IQMessageKeyType IQMessageKeyType_MAX = IQKeySetForbiddenWords;
const int IQMessageKeyType_ARRAYSIZE = IQMessageKeyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* IQMessageKeyType_descriptor();
inline const ::std::string& IQMessageKeyType_Name(IQMessageKeyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    IQMessageKeyType_descriptor(), value);
}
inline bool IQMessageKeyType_Parse(
    const ::std::string& name, IQMessageKeyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IQMessageKeyType>(
    IQMessageKeyType_descriptor(), name, value);
}
enum StreamEndCode {
  StreamEndCodeReloginBase = 100,
  StreamEndCodeReloginFromNav = 101,
  StreamEndCodeSystemShutdown = 111,
  StreamEndCodeNoReloginBase = 200
};
bool StreamEndCode_IsValid(int value);
const StreamEndCode StreamEndCode_MIN = StreamEndCodeReloginBase;
const StreamEndCode StreamEndCode_MAX = StreamEndCodeNoReloginBase;
const int StreamEndCode_ARRAYSIZE = StreamEndCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* StreamEndCode_descriptor();
inline const ::std::string& StreamEndCode_Name(StreamEndCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    StreamEndCode_descriptor(), value);
}
inline bool StreamEndCode_Parse(
    const ::std::string& name, StreamEndCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StreamEndCode>(
    StreamEndCode_descriptor(), name, value);
}
enum CategoryType {
  CategoryOrganizational = 1,
  CategorySessionList = 2,
  CategoryNavigation = 3,
  CategoryOPSNotification = 4,
  CategoryConfigSync = 6,
  CategoryMsgNotify = 7,
  CategoryCalendarSync = 8,
  CategoryOnlineClientSync = 9,
  CategoryAskLog = 10,
  CategoryClientSpecialNotice = 11,
  CategoryTickUser = 100,
  CategoryGlobalNotification = 98,
  CategorySpecifyNotification = 99,
  CategoryWorkWorldNotice = 12,
  CategoryHotLineSync = 13,
  CategoryMedalListSync = 14,
  CategoryMedalUserStatusListSync = 15,
  CategoryDiscoverUnread = 16
};
bool CategoryType_IsValid(int value);
const CategoryType CategoryType_MIN = CategoryOrganizational;
const CategoryType CategoryType_MAX = CategoryTickUser;
const int CategoryType_ARRAYSIZE = CategoryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CategoryType_descriptor();
inline const ::std::string& CategoryType_Name(CategoryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CategoryType_descriptor(), value);
}
inline bool CategoryType_Parse(
    const ::std::string& name, CategoryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CategoryType>(
    CategoryType_descriptor(), name, value);
}
enum PresenceKeyType {
  PresenceKeyPriority = 1,
  PresenceKeyVerifyFriend = 2,
  PresenceKeyManualAuthenticationConfirm = 3,
  PresenceKeyResult = 6,
  PresenceKeyNotify = 7,
  PresenceKeyError = 8
};
bool PresenceKeyType_IsValid(int value);
const PresenceKeyType PresenceKeyType_MIN = PresenceKeyPriority;
const PresenceKeyType PresenceKeyType_MAX = PresenceKeyError;
const int PresenceKeyType_ARRAYSIZE = PresenceKeyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PresenceKeyType_descriptor();
inline const ::std::string& PresenceKeyType_Name(PresenceKeyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PresenceKeyType_descriptor(), value);
}
inline bool PresenceKeyType_Parse(
    const ::std::string& name, PresenceKeyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PresenceKeyType>(
    PresenceKeyType_descriptor(), name, value);
}
// ===================================================================

class MessageKeyValue : public ::google::protobuf::Message {
 public:
  MessageKeyValue();
  virtual ~MessageKeyValue();

  MessageKeyValue(const MessageKeyValue& from);

  inline MessageKeyValue& operator=(const MessageKeyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageKeyValue& default_instance();

  void Swap(MessageKeyValue* other);

  // implements Message ----------------------------------------------

  MessageKeyValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageKeyValue& from);
  void MergeFrom(const MessageKeyValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:MessageKeyValue)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static MessageKeyValue* default_instance_;
};
// -------------------------------------------------------------------

class StringHeader : public ::google::protobuf::Message {
 public:
  StringHeader();
  virtual ~StringHeader();

  StringHeader(const StringHeader& from);

  inline StringHeader& operator=(const StringHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StringHeader& default_instance();

  void Swap(StringHeader* other);

  // implements Message ----------------------------------------------

  StringHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StringHeader& from);
  void MergeFrom(const StringHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MessageKeyValue params = 1;
  inline int params_size() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 1;
  inline const ::MessageKeyValue& params(int index) const;
  inline ::MessageKeyValue* mutable_params(int index);
  inline ::MessageKeyValue* add_params();
  inline const ::google::protobuf::RepeatedPtrField< ::MessageKeyValue >&
      params() const;
  inline ::google::protobuf::RepeatedPtrField< ::MessageKeyValue >*
      mutable_params();

  // optional string key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional .StringHeaderType definedKey = 4;
  inline bool has_definedkey() const;
  inline void clear_definedkey();
  static const int kDefinedKeyFieldNumber = 4;
  inline ::StringHeaderType definedkey() const;
  inline void set_definedkey(::StringHeaderType value);

  // @@protoc_insertion_point(class_scope:StringHeader)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_definedkey();
  inline void clear_has_definedkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MessageKeyValue > params_;
  ::std::string* key_;
  ::std::string* value_;
  int definedkey_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static StringHeader* default_instance_;
};
// -------------------------------------------------------------------

class PackageLength : public ::google::protobuf::Message {
 public:
  PackageLength();
  virtual ~PackageLength();

  PackageLength(const PackageLength& from);

  inline PackageLength& operator=(const PackageLength& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PackageLength& default_instance();

  void Swap(PackageLength* other);

  // implements Message ----------------------------------------------

  PackageLength* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PackageLength& from);
  void MergeFrom(const PackageLength& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 length = 1;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 1;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PackageLength)
 private:
  inline void set_has_length();
  inline void clear_has_length();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 length_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static PackageLength* default_instance_;
};
// -------------------------------------------------------------------

class ProtoHeader : public ::google::protobuf::Message {
 public:
  ProtoHeader();
  virtual ~ProtoHeader();

  ProtoHeader(const ProtoHeader& from);

  inline ProtoHeader& operator=(const ProtoHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoHeader& default_instance();

  void Swap(ProtoHeader* other);

  // implements Message ----------------------------------------------

  ProtoHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtoHeader& from);
  void MergeFrom(const ProtoHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // optional int32 options = 2;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 2;
  inline ::google::protobuf::int32 options() const;
  inline void set_options(::google::protobuf::int32 value);

  // repeated int32 optionlist = 3;
  inline int optionlist_size() const;
  inline void clear_optionlist();
  static const int kOptionlistFieldNumber = 3;
  inline ::google::protobuf::int32 optionlist(int index) const;
  inline void set_optionlist(int index, ::google::protobuf::int32 value);
  inline void add_optionlist(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      optionlist() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_optionlist();

  // optional int32 length = 4;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 4;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // optional string content = 5;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 5;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional bytes message = 6;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 6;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:ProtoHeader)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_options();
  inline void clear_has_options();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::int32 options_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > optionlist_;
  ::std::string* content_;
  ::std::string* message_;
  ::google::protobuf::int32 length_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static ProtoHeader* default_instance_;
};
// -------------------------------------------------------------------

class AuthMessage : public ::google::protobuf::Message {
 public:
  AuthMessage();
  virtual ~AuthMessage();

  AuthMessage(const AuthMessage& from);

  inline AuthMessage& operator=(const AuthMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthMessage& default_instance();

  void Swap(AuthMessage* other);

  // implements Message ----------------------------------------------

  AuthMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthMessage& from);
  void MergeFrom(const AuthMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mechanism = 1;
  inline bool has_mechanism() const;
  inline void clear_mechanism();
  static const int kMechanismFieldNumber = 1;
  inline const ::std::string& mechanism() const;
  inline void set_mechanism(const ::std::string& value);
  inline void set_mechanism(const char* value);
  inline void set_mechanism(const char* value, size_t size);
  inline ::std::string* mutable_mechanism();
  inline ::std::string* release_mechanism();
  inline void set_allocated_mechanism(::std::string* mechanism);

  // optional string method = 2;
  inline bool has_method() const;
  inline void clear_method();
  static const int kMethodFieldNumber = 2;
  inline const ::std::string& method() const;
  inline void set_method(const ::std::string& value);
  inline void set_method(const char* value);
  inline void set_method(const char* value, size_t size);
  inline ::std::string* mutable_method();
  inline ::std::string* release_method();
  inline void set_allocated_method(::std::string* method);

  // optional string msgId = 3;
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIdFieldNumber = 3;
  inline const ::std::string& msgid() const;
  inline void set_msgid(const ::std::string& value);
  inline void set_msgid(const char* value);
  inline void set_msgid(const char* value, size_t size);
  inline ::std::string* mutable_msgid();
  inline ::std::string* release_msgid();
  inline void set_allocated_msgid(::std::string* msgid);

  // optional string authKey = 4;
  inline bool has_authkey() const;
  inline void clear_authkey();
  static const int kAuthKeyFieldNumber = 4;
  inline const ::std::string& authkey() const;
  inline void set_authkey(const ::std::string& value);
  inline void set_authkey(const char* value);
  inline void set_authkey(const char* value, size_t size);
  inline ::std::string* mutable_authkey();
  inline ::std::string* release_authkey();
  inline void set_allocated_authkey(::std::string* authkey);

  // optional .MessageBody otherBody = 5;
  inline bool has_otherbody() const;
  inline void clear_otherbody();
  static const int kOtherBodyFieldNumber = 5;
  inline const ::MessageBody& otherbody() const;
  inline ::MessageBody* mutable_otherbody();
  inline ::MessageBody* release_otherbody();
  inline void set_allocated_otherbody(::MessageBody* otherbody);

  // @@protoc_insertion_point(class_scope:AuthMessage)
 private:
  inline void set_has_mechanism();
  inline void clear_has_mechanism();
  inline void set_has_method();
  inline void clear_has_method();
  inline void set_has_msgid();
  inline void clear_has_msgid();
  inline void set_has_authkey();
  inline void clear_has_authkey();
  inline void set_has_otherbody();
  inline void clear_has_otherbody();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* mechanism_;
  ::std::string* method_;
  ::std::string* msgid_;
  ::std::string* authkey_;
  ::MessageBody* otherbody_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static AuthMessage* default_instance_;
};
// -------------------------------------------------------------------

class WelcomeMessage : public ::google::protobuf::Message {
 public:
  WelcomeMessage();
  virtual ~WelcomeMessage();

  WelcomeMessage(const WelcomeMessage& from);

  inline WelcomeMessage& operator=(const WelcomeMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WelcomeMessage& default_instance();

  void Swap(WelcomeMessage* other);

  // implements Message ----------------------------------------------

  WelcomeMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WelcomeMessage& from);
  void MergeFrom(const WelcomeMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional string version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string user = 3;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 3;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // optional string sockmod = 4;
  inline bool has_sockmod() const;
  inline void clear_sockmod();
  static const int kSockmodFieldNumber = 4;
  inline const ::std::string& sockmod() const;
  inline void set_sockmod(const ::std::string& value);
  inline void set_sockmod(const char* value);
  inline void set_sockmod(const char* value, size_t size);
  inline ::std::string* mutable_sockmod();
  inline ::std::string* release_sockmod();
  inline void set_allocated_sockmod(::std::string* sockmod);

  // @@protoc_insertion_point(class_scope:WelcomeMessage)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_sockmod();
  inline void clear_has_sockmod();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* domain_;
  ::std::string* version_;
  ::std::string* user_;
  ::std::string* sockmod_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static WelcomeMessage* default_instance_;
};
// -------------------------------------------------------------------

class StreamBegin : public ::google::protobuf::Message {
 public:
  StreamBegin();
  virtual ~StreamBegin();

  StreamBegin(const StreamBegin& from);

  inline StreamBegin& operator=(const StreamBegin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamBegin& default_instance();

  void Swap(StreamBegin* other);

  // implements Message ----------------------------------------------

  StreamBegin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreamBegin& from);
  void MergeFrom(const StreamBegin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional string version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // repeated .MessageBody bodys = 3;
  inline int bodys_size() const;
  inline void clear_bodys();
  static const int kBodysFieldNumber = 3;
  inline const ::MessageBody& bodys(int index) const;
  inline ::MessageBody* mutable_bodys(int index);
  inline ::MessageBody* add_bodys();
  inline const ::google::protobuf::RepeatedPtrField< ::MessageBody >&
      bodys() const;
  inline ::google::protobuf::RepeatedPtrField< ::MessageBody >*
      mutable_bodys();

  // @@protoc_insertion_point(class_scope:StreamBegin)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* domain_;
  ::std::string* version_;
  ::google::protobuf::RepeatedPtrField< ::MessageBody > bodys_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static StreamBegin* default_instance_;
};
// -------------------------------------------------------------------

class StartTLS : public ::google::protobuf::Message {
 public:
  StartTLS();
  virtual ~StartTLS();

  StartTLS(const StartTLS& from);

  inline StartTLS& operator=(const StartTLS& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartTLS& default_instance();

  void Swap(StartTLS* other);

  // implements Message ----------------------------------------------

  StartTLS* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartTLS& from);
  void MergeFrom(const StartTLS& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:StartTLS)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static StartTLS* default_instance_;
};
// -------------------------------------------------------------------

class ProceedTLS : public ::google::protobuf::Message {
 public:
  ProceedTLS();
  virtual ~ProceedTLS();

  ProceedTLS(const ProceedTLS& from);

  inline ProceedTLS& operator=(const ProceedTLS& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProceedTLS& default_instance();

  void Swap(ProceedTLS* other);

  // implements Message ----------------------------------------------

  ProceedTLS* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProceedTLS& from);
  void MergeFrom(const ProceedTLS& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProceedTLS)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static ProceedTLS* default_instance_;
};
// -------------------------------------------------------------------

class StreamEnd : public ::google::protobuf::Message {
 public:
  StreamEnd();
  virtual ~StreamEnd();

  StreamEnd(const StreamEnd& from);

  inline StreamEnd& operator=(const StreamEnd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamEnd& default_instance();

  void Swap(StreamEnd* other);

  // implements Message ----------------------------------------------

  StreamEnd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreamEnd& from);
  void MergeFrom(const StreamEnd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string reason = 1;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 1;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // optional int32 code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:StreamEnd)
 private:
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* reason_;
  ::google::protobuf::int32 code_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static StreamEnd* default_instance_;
};
// -------------------------------------------------------------------

class UserConnect : public ::google::protobuf::Message {
 public:
  UserConnect();
  virtual ~UserConnect();

  UserConnect(const UserConnect& from);

  inline UserConnect& operator=(const UserConnect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserConnect& default_instance();

  void Swap(UserConnect* other);

  // implements Message ----------------------------------------------

  UserConnect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserConnect& from);
  void MergeFrom(const UserConnect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string domain = 1;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 1;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional string version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:UserConnect)
 private:
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* domain_;
  ::std::string* version_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static UserConnect* default_instance_;
};
// -------------------------------------------------------------------

class Capability : public ::google::protobuf::Message {
 public:
  Capability();
  virtual ~Capability();

  Capability(const Capability& from);

  inline Capability& operator=(const Capability& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Capability& default_instance();

  void Swap(Capability* other);

  // implements Message ----------------------------------------------

  Capability* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Capability& from);
  void MergeFrom(const Capability& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional .MessageBody bodys = 2;
  inline bool has_bodys() const;
  inline void clear_bodys();
  static const int kBodysFieldNumber = 2;
  inline const ::MessageBody& bodys() const;
  inline ::MessageBody* mutable_bodys();
  inline ::MessageBody* release_bodys();
  inline void set_allocated_bodys(::MessageBody* bodys);

  // @@protoc_insertion_point(class_scope:Capability)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_bodys();
  inline void clear_has_bodys();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* version_;
  ::MessageBody* bodys_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Capability* default_instance_;
};
// -------------------------------------------------------------------

class ResponseSucceeded : public ::google::protobuf::Message {
 public:
  ResponseSucceeded();
  virtual ~ResponseSucceeded();

  ResponseSucceeded(const ResponseSucceeded& from);

  inline ResponseSucceeded& operator=(const ResponseSucceeded& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseSucceeded& default_instance();

  void Swap(ResponseSucceeded* other);

  // implements Message ----------------------------------------------

  ResponseSucceeded* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseSucceeded& from);
  void MergeFrom(const ResponseSucceeded& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional string msgId = 2;
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIdFieldNumber = 2;
  inline const ::std::string& msgid() const;
  inline void set_msgid(const ::std::string& value);
  inline void set_msgid(const char* value);
  inline void set_msgid(const char* value, size_t size);
  inline ::std::string* mutable_msgid();
  inline ::std::string* release_msgid();
  inline void set_allocated_msgid(::std::string* msgid);

  // optional string info = 3;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 3;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // optional .MessageBody body = 4;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 4;
  inline const ::MessageBody& body() const;
  inline ::MessageBody* mutable_body();
  inline ::MessageBody* release_body();
  inline void set_allocated_body(::MessageBody* body);

  // @@protoc_insertion_point(class_scope:ResponseSucceeded)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_msgid();
  inline void clear_has_msgid();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_body();
  inline void clear_has_body();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* msgid_;
  ::std::string* info_;
  ::MessageBody* body_;
  ::google::protobuf::int32 code_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static ResponseSucceeded* default_instance_;
};
// -------------------------------------------------------------------

class ResponseFailure : public ::google::protobuf::Message {
 public:
  ResponseFailure();
  virtual ~ResponseFailure();

  ResponseFailure(const ResponseFailure& from);

  inline ResponseFailure& operator=(const ResponseFailure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseFailure& default_instance();

  void Swap(ResponseFailure* other);

  // implements Message ----------------------------------------------

  ResponseFailure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseFailure& from);
  void MergeFrom(const ResponseFailure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional string msgId = 2;
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIdFieldNumber = 2;
  inline const ::std::string& msgid() const;
  inline void set_msgid(const ::std::string& value);
  inline void set_msgid(const char* value);
  inline void set_msgid(const char* value, size_t size);
  inline ::std::string* mutable_msgid();
  inline ::std::string* release_msgid();
  inline void set_allocated_msgid(::std::string* msgid);

  // optional string error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void set_allocated_error(::std::string* error);

  // optional .MessageBody body = 4;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 4;
  inline const ::MessageBody& body() const;
  inline ::MessageBody* mutable_body();
  inline ::MessageBody* release_body();
  inline void set_allocated_body(::MessageBody* body);

  // @@protoc_insertion_point(class_scope:ResponseFailure)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_msgid();
  inline void clear_has_msgid();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_body();
  inline void clear_has_body();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* msgid_;
  ::std::string* error_;
  ::MessageBody* body_;
  ::google::protobuf::int32 code_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static ResponseFailure* default_instance_;
};
// -------------------------------------------------------------------

class ProtoMessage : public ::google::protobuf::Message {
 public:
  ProtoMessage();
  virtual ~ProtoMessage();

  ProtoMessage(const ProtoMessage& from);

  inline ProtoMessage& operator=(const ProtoMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoMessage& default_instance();

  void Swap(ProtoMessage* other);

  // implements Message ----------------------------------------------

  ProtoMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtoMessage& from);
  void MergeFrom(const ProtoMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 options = 1;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 1;
  inline ::google::protobuf::int32 options() const;
  inline void set_options(::google::protobuf::int32 value);

  // required int32 signalType = 2 [default = 0];
  inline bool has_signaltype() const;
  inline void clear_signaltype();
  static const int kSignalTypeFieldNumber = 2;
  inline ::google::protobuf::int32 signaltype() const;
  inline void set_signaltype(::google::protobuf::int32 value);

  // optional string from = 3;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 3;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const char* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  inline void set_allocated_from(::std::string* from);

  // optional string to = 4;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 4;
  inline const ::std::string& to() const;
  inline void set_to(const ::std::string& value);
  inline void set_to(const char* value);
  inline void set_to(const char* value, size_t size);
  inline ::std::string* mutable_to();
  inline ::std::string* release_to();
  inline void set_allocated_to(::std::string* to);

  // optional bytes message = 5;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 5;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional string realfrom = 6;
  inline bool has_realfrom() const;
  inline void clear_realfrom();
  static const int kRealfromFieldNumber = 6;
  inline const ::std::string& realfrom() const;
  inline void set_realfrom(const ::std::string& value);
  inline void set_realfrom(const char* value);
  inline void set_realfrom(const char* value, size_t size);
  inline ::std::string* mutable_realfrom();
  inline ::std::string* release_realfrom();
  inline void set_allocated_realfrom(::std::string* realfrom);

  // optional string realto = 7;
  inline bool has_realto() const;
  inline void clear_realto();
  static const int kRealtoFieldNumber = 7;
  inline const ::std::string& realto() const;
  inline void set_realto(const ::std::string& value);
  inline void set_realto(const char* value);
  inline void set_realto(const char* value, size_t size);
  inline ::std::string* mutable_realto();
  inline ::std::string* release_realto();
  inline void set_allocated_realto(::std::string* realto);

  // optional string originfrom = 8;
  inline bool has_originfrom() const;
  inline void clear_originfrom();
  static const int kOriginfromFieldNumber = 8;
  inline const ::std::string& originfrom() const;
  inline void set_originfrom(const ::std::string& value);
  inline void set_originfrom(const char* value);
  inline void set_originfrom(const char* value, size_t size);
  inline ::std::string* mutable_originfrom();
  inline ::std::string* release_originfrom();
  inline void set_allocated_originfrom(::std::string* originfrom);

  // optional string originto = 9;
  inline bool has_originto() const;
  inline void clear_originto();
  static const int kOrigintoFieldNumber = 9;
  inline const ::std::string& originto() const;
  inline void set_originto(const ::std::string& value);
  inline void set_originto(const char* value);
  inline void set_originto(const char* value, size_t size);
  inline ::std::string* mutable_originto();
  inline ::std::string* release_originto();
  inline void set_allocated_originto(::std::string* originto);

  // optional string origintype = 10;
  inline bool has_origintype() const;
  inline void clear_origintype();
  static const int kOrigintypeFieldNumber = 10;
  inline const ::std::string& origintype() const;
  inline void set_origintype(const ::std::string& value);
  inline void set_origintype(const char* value);
  inline void set_origintype(const char* value, size_t size);
  inline ::std::string* mutable_origintype();
  inline ::std::string* release_origintype();
  inline void set_allocated_origintype(::std::string* origintype);

  // optional string sendjid = 11;
  inline bool has_sendjid() const;
  inline void clear_sendjid();
  static const int kSendjidFieldNumber = 11;
  inline const ::std::string& sendjid() const;
  inline void set_sendjid(const ::std::string& value);
  inline void set_sendjid(const char* value);
  inline void set_sendjid(const char* value, size_t size);
  inline ::std::string* mutable_sendjid();
  inline ::std::string* release_sendjid();
  inline void set_allocated_sendjid(::std::string* sendjid);

  // @@protoc_insertion_point(class_scope:ProtoMessage)
 private:
  inline void set_has_options();
  inline void clear_has_options();
  inline void set_has_signaltype();
  inline void clear_has_signaltype();
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_realfrom();
  inline void clear_has_realfrom();
  inline void set_has_realto();
  inline void clear_has_realto();
  inline void set_has_originfrom();
  inline void clear_has_originfrom();
  inline void set_has_originto();
  inline void clear_has_originto();
  inline void set_has_origintype();
  inline void clear_has_origintype();
  inline void set_has_sendjid();
  inline void clear_has_sendjid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 options_;
  ::google::protobuf::int32 signaltype_;
  ::std::string* from_;
  ::std::string* to_;
  ::std::string* message_;
  ::std::string* realfrom_;
  ::std::string* realto_;
  ::std::string* originfrom_;
  ::std::string* originto_;
  ::std::string* origintype_;
  ::std::string* sendjid_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static ProtoMessage* default_instance_;
};
// -------------------------------------------------------------------

class MessageBody : public ::google::protobuf::Message {
 public:
  MessageBody();
  virtual ~MessageBody();

  MessageBody(const MessageBody& from);

  inline MessageBody& operator=(const MessageBody& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageBody& default_instance();

  void Swap(MessageBody* other);

  // implements Message ----------------------------------------------

  MessageBody* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageBody& from);
  void MergeFrom(const MessageBody& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .StringHeader headers = 1;
  inline int headers_size() const;
  inline void clear_headers();
  static const int kHeadersFieldNumber = 1;
  inline const ::StringHeader& headers(int index) const;
  inline ::StringHeader* mutable_headers(int index);
  inline ::StringHeader* add_headers();
  inline const ::google::protobuf::RepeatedPtrField< ::StringHeader >&
      headers() const;
  inline ::google::protobuf::RepeatedPtrField< ::StringHeader >*
      mutable_headers();

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // repeated .MessageBody bodys = 3;
  inline int bodys_size() const;
  inline void clear_bodys();
  static const int kBodysFieldNumber = 3;
  inline const ::MessageBody& bodys(int index) const;
  inline ::MessageBody* mutable_bodys(int index);
  inline ::MessageBody* add_bodys();
  inline const ::google::protobuf::RepeatedPtrField< ::MessageBody >&
      bodys() const;
  inline ::google::protobuf::RepeatedPtrField< ::MessageBody >*
      mutable_bodys();

  // @@protoc_insertion_point(class_scope:MessageBody)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::StringHeader > headers_;
  ::std::string* value_;
  ::google::protobuf::RepeatedPtrField< ::MessageBody > bodys_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static MessageBody* default_instance_;
};
// -------------------------------------------------------------------

class IQMessage : public ::google::protobuf::Message {
 public:
  IQMessage();
  virtual ~IQMessage();

  IQMessage(const IQMessage& from);

  inline IQMessage& operator=(const IQMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IQMessage& default_instance();

  void Swap(IQMessage* other);

  // implements Message ----------------------------------------------

  IQMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IQMessage& from);
  void MergeFrom(const IQMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string namespace = 1;
  inline bool has_namespace_() const;
  inline void clear_namespace_();
  static const int kNamespaceFieldNumber = 1;
  inline const ::std::string& namespace_() const;
  inline void set_namespace_(const ::std::string& value);
  inline void set_namespace_(const char* value);
  inline void set_namespace_(const char* value, size_t size);
  inline ::std::string* mutable_namespace_();
  inline ::std::string* release_namespace_();
  inline void set_allocated_namespace_(::std::string* namespace_);

  // optional string key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional string messageId = 4;
  inline bool has_messageid() const;
  inline void clear_messageid();
  static const int kMessageIdFieldNumber = 4;
  inline const ::std::string& messageid() const;
  inline void set_messageid(const ::std::string& value);
  inline void set_messageid(const char* value);
  inline void set_messageid(const char* value, size_t size);
  inline ::std::string* mutable_messageid();
  inline ::std::string* release_messageid();
  inline void set_allocated_messageid(::std::string* messageid);

  // optional .StringHeader header = 5;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 5;
  inline const ::StringHeader& header() const;
  inline ::StringHeader* mutable_header();
  inline ::StringHeader* release_header();
  inline void set_allocated_header(::StringHeader* header);

  // optional .MessageBody body = 6;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 6;
  inline const ::MessageBody& body() const;
  inline ::MessageBody* mutable_body();
  inline ::MessageBody* release_body();
  inline void set_allocated_body(::MessageBody* body);

  // optional int64 receivedTime = 7;
  inline bool has_receivedtime() const;
  inline void clear_receivedtime();
  static const int kReceivedTimeFieldNumber = 7;
  inline ::google::protobuf::int64 receivedtime() const;
  inline void set_receivedtime(::google::protobuf::int64 value);

  // optional int64 transferTime = 8;
  inline bool has_transfertime() const;
  inline void clear_transfertime();
  static const int kTransferTimeFieldNumber = 8;
  inline ::google::protobuf::int64 transfertime() const;
  inline void set_transfertime(::google::protobuf::int64 value);

  // repeated .StringHeader headers = 9;
  inline int headers_size() const;
  inline void clear_headers();
  static const int kHeadersFieldNumber = 9;
  inline const ::StringHeader& headers(int index) const;
  inline ::StringHeader* mutable_headers(int index);
  inline ::StringHeader* add_headers();
  inline const ::google::protobuf::RepeatedPtrField< ::StringHeader >&
      headers() const;
  inline ::google::protobuf::RepeatedPtrField< ::StringHeader >*
      mutable_headers();

  // repeated .MessageBody bodys = 10;
  inline int bodys_size() const;
  inline void clear_bodys();
  static const int kBodysFieldNumber = 10;
  inline const ::MessageBody& bodys(int index) const;
  inline ::MessageBody* mutable_bodys(int index);
  inline ::MessageBody* add_bodys();
  inline const ::google::protobuf::RepeatedPtrField< ::MessageBody >&
      bodys() const;
  inline ::google::protobuf::RepeatedPtrField< ::MessageBody >*
      mutable_bodys();

  // optional .IQMessageKeyType definedKey = 11;
  inline bool has_definedkey() const;
  inline void clear_definedkey();
  static const int kDefinedKeyFieldNumber = 11;
  inline ::IQMessageKeyType definedkey() const;
  inline void set_definedkey(::IQMessageKeyType value);

  // @@protoc_insertion_point(class_scope:IQMessage)
 private:
  inline void set_has_namespace_();
  inline void clear_has_namespace_();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_messageid();
  inline void clear_has_messageid();
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_body();
  inline void clear_has_body();
  inline void set_has_receivedtime();
  inline void clear_has_receivedtime();
  inline void set_has_transfertime();
  inline void clear_has_transfertime();
  inline void set_has_definedkey();
  inline void clear_has_definedkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* namespace__;
  ::std::string* key_;
  ::std::string* value_;
  ::std::string* messageid_;
  ::StringHeader* header_;
  ::MessageBody* body_;
  ::google::protobuf::int64 receivedtime_;
  ::google::protobuf::int64 transfertime_;
  ::google::protobuf::RepeatedPtrField< ::StringHeader > headers_;
  ::google::protobuf::RepeatedPtrField< ::MessageBody > bodys_;
  int definedkey_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static IQMessage* default_instance_;
};
// -------------------------------------------------------------------

class PresenceMessage : public ::google::protobuf::Message {
 public:
  PresenceMessage();
  virtual ~PresenceMessage();

  PresenceMessage(const PresenceMessage& from);

  inline PresenceMessage& operator=(const PresenceMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PresenceMessage& default_instance();

  void Swap(PresenceMessage* other);

  // implements Message ----------------------------------------------

  PresenceMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PresenceMessage& from);
  void MergeFrom(const PresenceMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string namespace = 1;
  inline bool has_namespace_() const;
  inline void clear_namespace_();
  static const int kNamespaceFieldNumber = 1;
  inline const ::std::string& namespace_() const;
  inline void set_namespace_(const ::std::string& value);
  inline void set_namespace_(const char* value);
  inline void set_namespace_(const char* value, size_t size);
  inline ::std::string* mutable_namespace_();
  inline ::std::string* release_namespace_();
  inline void set_allocated_namespace_(::std::string* namespace_);

  // optional string key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional string messageId = 4;
  inline bool has_messageid() const;
  inline void clear_messageid();
  static const int kMessageIdFieldNumber = 4;
  inline const ::std::string& messageid() const;
  inline void set_messageid(const ::std::string& value);
  inline void set_messageid(const char* value);
  inline void set_messageid(const char* value, size_t size);
  inline ::std::string* mutable_messageid();
  inline ::std::string* release_messageid();
  inline void set_allocated_messageid(::std::string* messageid);

  // optional .StringHeader header = 5;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 5;
  inline const ::StringHeader& header() const;
  inline ::StringHeader* mutable_header();
  inline ::StringHeader* release_header();
  inline void set_allocated_header(::StringHeader* header);

  // optional .MessageBody body = 6;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 6;
  inline const ::MessageBody& body() const;
  inline ::MessageBody* mutable_body();
  inline ::MessageBody* release_body();
  inline void set_allocated_body(::MessageBody* body);

  // optional int64 receivedTime = 7;
  inline bool has_receivedtime() const;
  inline void clear_receivedtime();
  static const int kReceivedTimeFieldNumber = 7;
  inline ::google::protobuf::int64 receivedtime() const;
  inline void set_receivedtime(::google::protobuf::int64 value);

  // optional int64 transferTime = 8;
  inline bool has_transfertime() const;
  inline void clear_transfertime();
  static const int kTransferTimeFieldNumber = 8;
  inline ::google::protobuf::int64 transfertime() const;
  inline void set_transfertime(::google::protobuf::int64 value);

  // repeated .StringHeader headers = 9;
  inline int headers_size() const;
  inline void clear_headers();
  static const int kHeadersFieldNumber = 9;
  inline const ::StringHeader& headers(int index) const;
  inline ::StringHeader* mutable_headers(int index);
  inline ::StringHeader* add_headers();
  inline const ::google::protobuf::RepeatedPtrField< ::StringHeader >&
      headers() const;
  inline ::google::protobuf::RepeatedPtrField< ::StringHeader >*
      mutable_headers();

  // repeated .MessageBody bodys = 10;
  inline int bodys_size() const;
  inline void clear_bodys();
  static const int kBodysFieldNumber = 10;
  inline const ::MessageBody& bodys(int index) const;
  inline ::MessageBody* mutable_bodys(int index);
  inline ::MessageBody* add_bodys();
  inline const ::google::protobuf::RepeatedPtrField< ::MessageBody >&
      bodys() const;
  inline ::google::protobuf::RepeatedPtrField< ::MessageBody >*
      mutable_bodys();

  // optional .PresenceKeyType definedKey = 11;
  inline bool has_definedkey() const;
  inline void clear_definedkey();
  static const int kDefinedKeyFieldNumber = 11;
  inline ::PresenceKeyType definedkey() const;
  inline void set_definedkey(::PresenceKeyType value);

  // optional int32 categoryType = 12;
  inline bool has_categorytype() const;
  inline void clear_categorytype();
  static const int kCategoryTypeFieldNumber = 12;
  inline ::google::protobuf::int32 categorytype() const;
  inline void set_categorytype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PresenceMessage)
 private:
  inline void set_has_namespace_();
  inline void clear_has_namespace_();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_messageid();
  inline void clear_has_messageid();
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_body();
  inline void clear_has_body();
  inline void set_has_receivedtime();
  inline void clear_has_receivedtime();
  inline void set_has_transfertime();
  inline void clear_has_transfertime();
  inline void set_has_definedkey();
  inline void clear_has_definedkey();
  inline void set_has_categorytype();
  inline void clear_has_categorytype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* namespace__;
  ::std::string* key_;
  ::std::string* value_;
  ::std::string* messageid_;
  ::StringHeader* header_;
  ::MessageBody* body_;
  ::google::protobuf::int64 receivedtime_;
  ::google::protobuf::int64 transfertime_;
  ::google::protobuf::RepeatedPtrField< ::StringHeader > headers_;
  ::google::protobuf::RepeatedPtrField< ::MessageBody > bodys_;
  int definedkey_;
  ::google::protobuf::int32 categorytype_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static PresenceMessage* default_instance_;
};
// -------------------------------------------------------------------

class XmppMessage : public ::google::protobuf::Message {
 public:
  XmppMessage();
  virtual ~XmppMessage();

  XmppMessage(const XmppMessage& from);

  inline XmppMessage& operator=(const XmppMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const XmppMessage& default_instance();

  void Swap(XmppMessage* other);

  // implements Message ----------------------------------------------

  XmppMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XmppMessage& from);
  void MergeFrom(const XmppMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 messageType = 1 [default = 0];
  inline bool has_messagetype() const;
  inline void clear_messagetype();
  static const int kMessageTypeFieldNumber = 1;
  inline ::google::protobuf::int32 messagetype() const;
  inline void set_messagetype(::google::protobuf::int32 value);

  // required int32 clientType = 2 [default = 0];
  inline bool has_clienttype() const;
  inline void clear_clienttype();
  static const int kClientTypeFieldNumber = 2;
  inline ::google::protobuf::int32 clienttype() const;
  inline void set_clienttype(::google::protobuf::int32 value);

  // required int64 clientVersion = 3;
  inline bool has_clientversion() const;
  inline void clear_clientversion();
  static const int kClientVersionFieldNumber = 3;
  inline ::google::protobuf::int64 clientversion() const;
  inline void set_clientversion(::google::protobuf::int64 value);

  // optional string namespace = 4;
  inline bool has_namespace_() const;
  inline void clear_namespace_();
  static const int kNamespaceFieldNumber = 4;
  inline const ::std::string& namespace_() const;
  inline void set_namespace_(const ::std::string& value);
  inline void set_namespace_(const char* value);
  inline void set_namespace_(const char* value, size_t size);
  inline ::std::string* mutable_namespace_();
  inline ::std::string* release_namespace_();
  inline void set_allocated_namespace_(::std::string* namespace_);

  // optional string key = 5;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 5;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string value = 6;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 6;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional string messageId = 7;
  inline bool has_messageid() const;
  inline void clear_messageid();
  static const int kMessageIdFieldNumber = 7;
  inline const ::std::string& messageid() const;
  inline void set_messageid(const ::std::string& value);
  inline void set_messageid(const char* value);
  inline void set_messageid(const char* value, size_t size);
  inline ::std::string* mutable_messageid();
  inline ::std::string* release_messageid();
  inline void set_allocated_messageid(::std::string* messageid);

  // optional .StringHeader header = 8;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 8;
  inline const ::StringHeader& header() const;
  inline ::StringHeader* mutable_header();
  inline ::StringHeader* release_header();
  inline void set_allocated_header(::StringHeader* header);

  // optional .MessageBody body = 9;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 9;
  inline const ::MessageBody& body() const;
  inline ::MessageBody* mutable_body();
  inline ::MessageBody* release_body();
  inline void set_allocated_body(::MessageBody* body);

  // optional int64 receivedTime = 10;
  inline bool has_receivedtime() const;
  inline void clear_receivedtime();
  static const int kReceivedTimeFieldNumber = 10;
  inline ::google::protobuf::int64 receivedtime() const;
  inline void set_receivedtime(::google::protobuf::int64 value);

  // optional int64 transferTime = 11;
  inline bool has_transfertime() const;
  inline void clear_transfertime();
  static const int kTransferTimeFieldNumber = 11;
  inline ::google::protobuf::int64 transfertime() const;
  inline void set_transfertime(::google::protobuf::int64 value);

  // repeated .StringHeader headers = 12;
  inline int headers_size() const;
  inline void clear_headers();
  static const int kHeadersFieldNumber = 12;
  inline const ::StringHeader& headers(int index) const;
  inline ::StringHeader* mutable_headers(int index);
  inline ::StringHeader* add_headers();
  inline const ::google::protobuf::RepeatedPtrField< ::StringHeader >&
      headers() const;
  inline ::google::protobuf::RepeatedPtrField< ::StringHeader >*
      mutable_headers();

  // repeated .MessageBody bodys = 13;
  inline int bodys_size() const;
  inline void clear_bodys();
  static const int kBodysFieldNumber = 13;
  inline const ::MessageBody& bodys(int index) const;
  inline ::MessageBody* mutable_bodys(int index);
  inline ::MessageBody* add_bodys();
  inline const ::google::protobuf::RepeatedPtrField< ::MessageBody >&
      bodys() const;
  inline ::google::protobuf::RepeatedPtrField< ::MessageBody >*
      mutable_bodys();

  // @@protoc_insertion_point(class_scope:XmppMessage)
 private:
  inline void set_has_messagetype();
  inline void clear_has_messagetype();
  inline void set_has_clienttype();
  inline void clear_has_clienttype();
  inline void set_has_clientversion();
  inline void clear_has_clientversion();
  inline void set_has_namespace_();
  inline void clear_has_namespace_();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_messageid();
  inline void clear_has_messageid();
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_body();
  inline void clear_has_body();
  inline void set_has_receivedtime();
  inline void clear_has_receivedtime();
  inline void set_has_transfertime();
  inline void clear_has_transfertime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 messagetype_;
  ::google::protobuf::int32 clienttype_;
  ::google::protobuf::int64 clientversion_;
  ::std::string* namespace__;
  ::std::string* key_;
  ::std::string* value_;
  ::std::string* messageid_;
  ::StringHeader* header_;
  ::MessageBody* body_;
  ::google::protobuf::int64 receivedtime_;
  ::google::protobuf::int64 transfertime_;
  ::google::protobuf::RepeatedPtrField< ::StringHeader > headers_;
  ::google::protobuf::RepeatedPtrField< ::MessageBody > bodys_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static XmppMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// MessageKeyValue

// optional string key = 1;
inline bool MessageKeyValue::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageKeyValue::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageKeyValue::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageKeyValue::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& MessageKeyValue::key() const {
  // @@protoc_insertion_point(field_get:MessageKeyValue.key)
  return *key_;
}
inline void MessageKeyValue::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:MessageKeyValue.key)
}
inline void MessageKeyValue::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:MessageKeyValue.key)
}
inline void MessageKeyValue::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MessageKeyValue.key)
}
inline ::std::string* MessageKeyValue::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MessageKeyValue.key)
  return key_;
}
inline ::std::string* MessageKeyValue::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MessageKeyValue::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MessageKeyValue.key)
}

// optional string value = 2;
inline bool MessageKeyValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageKeyValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageKeyValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageKeyValue::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& MessageKeyValue::value() const {
  // @@protoc_insertion_point(field_get:MessageKeyValue.value)
  return *value_;
}
inline void MessageKeyValue::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:MessageKeyValue.value)
}
inline void MessageKeyValue::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:MessageKeyValue.value)
}
inline void MessageKeyValue::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MessageKeyValue.value)
}
inline ::std::string* MessageKeyValue::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MessageKeyValue.value)
  return value_;
}
inline ::std::string* MessageKeyValue::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MessageKeyValue::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MessageKeyValue.value)
}

// -------------------------------------------------------------------

// StringHeader

// repeated .MessageKeyValue params = 1;
inline int StringHeader::params_size() const {
  return params_.size();
}
inline void StringHeader::clear_params() {
  params_.Clear();
}
inline const ::MessageKeyValue& StringHeader::params(int index) const {
  // @@protoc_insertion_point(field_get:StringHeader.params)
  return params_.Get(index);
}
inline ::MessageKeyValue* StringHeader::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:StringHeader.params)
  return params_.Mutable(index);
}
inline ::MessageKeyValue* StringHeader::add_params() {
  // @@protoc_insertion_point(field_add:StringHeader.params)
  return params_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MessageKeyValue >&
StringHeader::params() const {
  // @@protoc_insertion_point(field_list:StringHeader.params)
  return params_;
}
inline ::google::protobuf::RepeatedPtrField< ::MessageKeyValue >*
StringHeader::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:StringHeader.params)
  return &params_;
}

// optional string key = 2;
inline bool StringHeader::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StringHeader::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StringHeader::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StringHeader::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& StringHeader::key() const {
  // @@protoc_insertion_point(field_get:StringHeader.key)
  return *key_;
}
inline void StringHeader::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:StringHeader.key)
}
inline void StringHeader::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:StringHeader.key)
}
inline void StringHeader::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:StringHeader.key)
}
inline ::std::string* StringHeader::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:StringHeader.key)
  return key_;
}
inline ::std::string* StringHeader::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StringHeader::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:StringHeader.key)
}

// optional string value = 3;
inline bool StringHeader::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StringHeader::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StringHeader::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StringHeader::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& StringHeader::value() const {
  // @@protoc_insertion_point(field_get:StringHeader.value)
  return *value_;
}
inline void StringHeader::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:StringHeader.value)
}
inline void StringHeader::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:StringHeader.value)
}
inline void StringHeader::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:StringHeader.value)
}
inline ::std::string* StringHeader::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:StringHeader.value)
  return value_;
}
inline ::std::string* StringHeader::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StringHeader::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:StringHeader.value)
}

// optional .StringHeaderType definedKey = 4;
inline bool StringHeader::has_definedkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StringHeader::set_has_definedkey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StringHeader::clear_has_definedkey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StringHeader::clear_definedkey() {
  definedkey_ = 1;
  clear_has_definedkey();
}
inline ::StringHeaderType StringHeader::definedkey() const {
  // @@protoc_insertion_point(field_get:StringHeader.definedKey)
  return static_cast< ::StringHeaderType >(definedkey_);
}
inline void StringHeader::set_definedkey(::StringHeaderType value) {
  assert(::StringHeaderType_IsValid(value));
  set_has_definedkey();
  definedkey_ = value;
  // @@protoc_insertion_point(field_set:StringHeader.definedKey)
}

// -------------------------------------------------------------------

// PackageLength

// optional int32 length = 1;
inline bool PackageLength::has_length() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PackageLength::set_has_length() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PackageLength::clear_has_length() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PackageLength::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 PackageLength::length() const {
  // @@protoc_insertion_point(field_get:PackageLength.length)
  return length_;
}
inline void PackageLength::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:PackageLength.length)
}

// -------------------------------------------------------------------

// ProtoHeader

// optional int32 version = 1;
inline bool ProtoHeader::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoHeader::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoHeader::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoHeader::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 ProtoHeader::version() const {
  // @@protoc_insertion_point(field_get:ProtoHeader.version)
  return version_;
}
inline void ProtoHeader::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:ProtoHeader.version)
}

// optional int32 options = 2;
inline bool ProtoHeader::has_options() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoHeader::set_has_options() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoHeader::clear_has_options() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoHeader::clear_options() {
  options_ = 0;
  clear_has_options();
}
inline ::google::protobuf::int32 ProtoHeader::options() const {
  // @@protoc_insertion_point(field_get:ProtoHeader.options)
  return options_;
}
inline void ProtoHeader::set_options(::google::protobuf::int32 value) {
  set_has_options();
  options_ = value;
  // @@protoc_insertion_point(field_set:ProtoHeader.options)
}

// repeated int32 optionlist = 3;
inline int ProtoHeader::optionlist_size() const {
  return optionlist_.size();
}
inline void ProtoHeader::clear_optionlist() {
  optionlist_.Clear();
}
inline ::google::protobuf::int32 ProtoHeader::optionlist(int index) const {
  // @@protoc_insertion_point(field_get:ProtoHeader.optionlist)
  return optionlist_.Get(index);
}
inline void ProtoHeader::set_optionlist(int index, ::google::protobuf::int32 value) {
  optionlist_.Set(index, value);
  // @@protoc_insertion_point(field_set:ProtoHeader.optionlist)
}
inline void ProtoHeader::add_optionlist(::google::protobuf::int32 value) {
  optionlist_.Add(value);
  // @@protoc_insertion_point(field_add:ProtoHeader.optionlist)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ProtoHeader::optionlist() const {
  // @@protoc_insertion_point(field_list:ProtoHeader.optionlist)
  return optionlist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ProtoHeader::mutable_optionlist() {
  // @@protoc_insertion_point(field_mutable_list:ProtoHeader.optionlist)
  return &optionlist_;
}

// optional int32 length = 4;
inline bool ProtoHeader::has_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoHeader::set_has_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoHeader::clear_has_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoHeader::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 ProtoHeader::length() const {
  // @@protoc_insertion_point(field_get:ProtoHeader.length)
  return length_;
}
inline void ProtoHeader::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:ProtoHeader.length)
}

// optional string content = 5;
inline bool ProtoHeader::has_content() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtoHeader::set_has_content() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtoHeader::clear_has_content() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtoHeader::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& ProtoHeader::content() const {
  // @@protoc_insertion_point(field_get:ProtoHeader.content)
  return *content_;
}
inline void ProtoHeader::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:ProtoHeader.content)
}
inline void ProtoHeader::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:ProtoHeader.content)
}
inline void ProtoHeader::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ProtoHeader.content)
}
inline ::std::string* ProtoHeader::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ProtoHeader.content)
  return content_;
}
inline ::std::string* ProtoHeader::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProtoHeader::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoHeader.content)
}

// optional bytes message = 6;
inline bool ProtoHeader::has_message() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProtoHeader::set_has_message() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProtoHeader::clear_has_message() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProtoHeader::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ProtoHeader::message() const {
  // @@protoc_insertion_point(field_get:ProtoHeader.message)
  return *message_;
}
inline void ProtoHeader::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:ProtoHeader.message)
}
inline void ProtoHeader::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:ProtoHeader.message)
}
inline void ProtoHeader::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ProtoHeader.message)
}
inline ::std::string* ProtoHeader::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ProtoHeader.message)
  return message_;
}
inline ::std::string* ProtoHeader::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProtoHeader::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoHeader.message)
}

// -------------------------------------------------------------------

// AuthMessage

// optional string mechanism = 1;
inline bool AuthMessage::has_mechanism() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthMessage::set_has_mechanism() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthMessage::clear_has_mechanism() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthMessage::clear_mechanism() {
  if (mechanism_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mechanism_->clear();
  }
  clear_has_mechanism();
}
inline const ::std::string& AuthMessage::mechanism() const {
  // @@protoc_insertion_point(field_get:AuthMessage.mechanism)
  return *mechanism_;
}
inline void AuthMessage::set_mechanism(const ::std::string& value) {
  set_has_mechanism();
  if (mechanism_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mechanism_ = new ::std::string;
  }
  mechanism_->assign(value);
  // @@protoc_insertion_point(field_set:AuthMessage.mechanism)
}
inline void AuthMessage::set_mechanism(const char* value) {
  set_has_mechanism();
  if (mechanism_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mechanism_ = new ::std::string;
  }
  mechanism_->assign(value);
  // @@protoc_insertion_point(field_set_char:AuthMessage.mechanism)
}
inline void AuthMessage::set_mechanism(const char* value, size_t size) {
  set_has_mechanism();
  if (mechanism_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mechanism_ = new ::std::string;
  }
  mechanism_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AuthMessage.mechanism)
}
inline ::std::string* AuthMessage::mutable_mechanism() {
  set_has_mechanism();
  if (mechanism_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mechanism_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AuthMessage.mechanism)
  return mechanism_;
}
inline ::std::string* AuthMessage::release_mechanism() {
  clear_has_mechanism();
  if (mechanism_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mechanism_;
    mechanism_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AuthMessage::set_allocated_mechanism(::std::string* mechanism) {
  if (mechanism_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mechanism_;
  }
  if (mechanism) {
    set_has_mechanism();
    mechanism_ = mechanism;
  } else {
    clear_has_mechanism();
    mechanism_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AuthMessage.mechanism)
}

// optional string method = 2;
inline bool AuthMessage::has_method() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthMessage::set_has_method() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthMessage::clear_has_method() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthMessage::clear_method() {
  if (method_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_->clear();
  }
  clear_has_method();
}
inline const ::std::string& AuthMessage::method() const {
  // @@protoc_insertion_point(field_get:AuthMessage.method)
  return *method_;
}
inline void AuthMessage::set_method(const ::std::string& value) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_ = new ::std::string;
  }
  method_->assign(value);
  // @@protoc_insertion_point(field_set:AuthMessage.method)
}
inline void AuthMessage::set_method(const char* value) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_ = new ::std::string;
  }
  method_->assign(value);
  // @@protoc_insertion_point(field_set_char:AuthMessage.method)
}
inline void AuthMessage::set_method(const char* value, size_t size) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_ = new ::std::string;
  }
  method_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AuthMessage.method)
}
inline ::std::string* AuthMessage::mutable_method() {
  set_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AuthMessage.method)
  return method_;
}
inline ::std::string* AuthMessage::release_method() {
  clear_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = method_;
    method_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AuthMessage::set_allocated_method(::std::string* method) {
  if (method_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete method_;
  }
  if (method) {
    set_has_method();
    method_ = method;
  } else {
    clear_has_method();
    method_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AuthMessage.method)
}

// optional string msgId = 3;
inline bool AuthMessage::has_msgid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuthMessage::set_has_msgid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuthMessage::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuthMessage::clear_msgid() {
  if (msgid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_->clear();
  }
  clear_has_msgid();
}
inline const ::std::string& AuthMessage::msgid() const {
  // @@protoc_insertion_point(field_get:AuthMessage.msgId)
  return *msgid_;
}
inline void AuthMessage::set_msgid(const ::std::string& value) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
  // @@protoc_insertion_point(field_set:AuthMessage.msgId)
}
inline void AuthMessage::set_msgid(const char* value) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
  // @@protoc_insertion_point(field_set_char:AuthMessage.msgId)
}
inline void AuthMessage::set_msgid(const char* value, size_t size) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AuthMessage.msgId)
}
inline ::std::string* AuthMessage::mutable_msgid() {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AuthMessage.msgId)
  return msgid_;
}
inline ::std::string* AuthMessage::release_msgid() {
  clear_has_msgid();
  if (msgid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msgid_;
    msgid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AuthMessage::set_allocated_msgid(::std::string* msgid) {
  if (msgid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msgid_;
  }
  if (msgid) {
    set_has_msgid();
    msgid_ = msgid;
  } else {
    clear_has_msgid();
    msgid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AuthMessage.msgId)
}

// optional string authKey = 4;
inline bool AuthMessage::has_authkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AuthMessage::set_has_authkey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AuthMessage::clear_has_authkey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AuthMessage::clear_authkey() {
  if (authkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authkey_->clear();
  }
  clear_has_authkey();
}
inline const ::std::string& AuthMessage::authkey() const {
  // @@protoc_insertion_point(field_get:AuthMessage.authKey)
  return *authkey_;
}
inline void AuthMessage::set_authkey(const ::std::string& value) {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authkey_ = new ::std::string;
  }
  authkey_->assign(value);
  // @@protoc_insertion_point(field_set:AuthMessage.authKey)
}
inline void AuthMessage::set_authkey(const char* value) {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authkey_ = new ::std::string;
  }
  authkey_->assign(value);
  // @@protoc_insertion_point(field_set_char:AuthMessage.authKey)
}
inline void AuthMessage::set_authkey(const char* value, size_t size) {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authkey_ = new ::std::string;
  }
  authkey_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AuthMessage.authKey)
}
inline ::std::string* AuthMessage::mutable_authkey() {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    authkey_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:AuthMessage.authKey)
  return authkey_;
}
inline ::std::string* AuthMessage::release_authkey() {
  clear_has_authkey();
  if (authkey_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = authkey_;
    authkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AuthMessage::set_allocated_authkey(::std::string* authkey) {
  if (authkey_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete authkey_;
  }
  if (authkey) {
    set_has_authkey();
    authkey_ = authkey;
  } else {
    clear_has_authkey();
    authkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:AuthMessage.authKey)
}

// optional .MessageBody otherBody = 5;
inline bool AuthMessage::has_otherbody() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AuthMessage::set_has_otherbody() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AuthMessage::clear_has_otherbody() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AuthMessage::clear_otherbody() {
  if (otherbody_ != NULL) otherbody_->::MessageBody::Clear();
  clear_has_otherbody();
}
inline const ::MessageBody& AuthMessage::otherbody() const {
  // @@protoc_insertion_point(field_get:AuthMessage.otherBody)
  return otherbody_ != NULL ? *otherbody_ : *default_instance_->otherbody_;
}
inline ::MessageBody* AuthMessage::mutable_otherbody() {
  set_has_otherbody();
  if (otherbody_ == NULL) otherbody_ = new ::MessageBody;
  // @@protoc_insertion_point(field_mutable:AuthMessage.otherBody)
  return otherbody_;
}
inline ::MessageBody* AuthMessage::release_otherbody() {
  clear_has_otherbody();
  ::MessageBody* temp = otherbody_;
  otherbody_ = NULL;
  return temp;
}
inline void AuthMessage::set_allocated_otherbody(::MessageBody* otherbody) {
  delete otherbody_;
  otherbody_ = otherbody;
  if (otherbody) {
    set_has_otherbody();
  } else {
    clear_has_otherbody();
  }
  // @@protoc_insertion_point(field_set_allocated:AuthMessage.otherBody)
}

// -------------------------------------------------------------------

// WelcomeMessage

// optional string domain = 1;
inline bool WelcomeMessage::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WelcomeMessage::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WelcomeMessage::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WelcomeMessage::clear_domain() {
  if (domain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& WelcomeMessage::domain() const {
  // @@protoc_insertion_point(field_get:WelcomeMessage.domain)
  return *domain_;
}
inline void WelcomeMessage::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
  // @@protoc_insertion_point(field_set:WelcomeMessage.domain)
}
inline void WelcomeMessage::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
  // @@protoc_insertion_point(field_set_char:WelcomeMessage.domain)
}
inline void WelcomeMessage::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:WelcomeMessage.domain)
}
inline ::std::string* WelcomeMessage::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:WelcomeMessage.domain)
  return domain_;
}
inline ::std::string* WelcomeMessage::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WelcomeMessage::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:WelcomeMessage.domain)
}

// optional string version = 2;
inline bool WelcomeMessage::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WelcomeMessage::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WelcomeMessage::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WelcomeMessage::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& WelcomeMessage::version() const {
  // @@protoc_insertion_point(field_get:WelcomeMessage.version)
  return *version_;
}
inline void WelcomeMessage::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:WelcomeMessage.version)
}
inline void WelcomeMessage::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:WelcomeMessage.version)
}
inline void WelcomeMessage::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:WelcomeMessage.version)
}
inline ::std::string* WelcomeMessage::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:WelcomeMessage.version)
  return version_;
}
inline ::std::string* WelcomeMessage::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WelcomeMessage::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:WelcomeMessage.version)
}

// optional string user = 3;
inline bool WelcomeMessage::has_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WelcomeMessage::set_has_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WelcomeMessage::clear_has_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WelcomeMessage::clear_user() {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& WelcomeMessage::user() const {
  // @@protoc_insertion_point(field_get:WelcomeMessage.user)
  return *user_;
}
inline void WelcomeMessage::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set:WelcomeMessage.user)
}
inline void WelcomeMessage::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set_char:WelcomeMessage.user)
}
inline void WelcomeMessage::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:WelcomeMessage.user)
}
inline ::std::string* WelcomeMessage::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:WelcomeMessage.user)
  return user_;
}
inline ::std::string* WelcomeMessage::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WelcomeMessage::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:WelcomeMessage.user)
}

// optional string sockmod = 4;
inline bool WelcomeMessage::has_sockmod() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WelcomeMessage::set_has_sockmod() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WelcomeMessage::clear_has_sockmod() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WelcomeMessage::clear_sockmod() {
  if (sockmod_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sockmod_->clear();
  }
  clear_has_sockmod();
}
inline const ::std::string& WelcomeMessage::sockmod() const {
  // @@protoc_insertion_point(field_get:WelcomeMessage.sockmod)
  return *sockmod_;
}
inline void WelcomeMessage::set_sockmod(const ::std::string& value) {
  set_has_sockmod();
  if (sockmod_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sockmod_ = new ::std::string;
  }
  sockmod_->assign(value);
  // @@protoc_insertion_point(field_set:WelcomeMessage.sockmod)
}
inline void WelcomeMessage::set_sockmod(const char* value) {
  set_has_sockmod();
  if (sockmod_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sockmod_ = new ::std::string;
  }
  sockmod_->assign(value);
  // @@protoc_insertion_point(field_set_char:WelcomeMessage.sockmod)
}
inline void WelcomeMessage::set_sockmod(const char* value, size_t size) {
  set_has_sockmod();
  if (sockmod_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sockmod_ = new ::std::string;
  }
  sockmod_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:WelcomeMessage.sockmod)
}
inline ::std::string* WelcomeMessage::mutable_sockmod() {
  set_has_sockmod();
  if (sockmod_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sockmod_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:WelcomeMessage.sockmod)
  return sockmod_;
}
inline ::std::string* WelcomeMessage::release_sockmod() {
  clear_has_sockmod();
  if (sockmod_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sockmod_;
    sockmod_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WelcomeMessage::set_allocated_sockmod(::std::string* sockmod) {
  if (sockmod_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sockmod_;
  }
  if (sockmod) {
    set_has_sockmod();
    sockmod_ = sockmod;
  } else {
    clear_has_sockmod();
    sockmod_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:WelcomeMessage.sockmod)
}

// -------------------------------------------------------------------

// StreamBegin

// optional string domain = 1;
inline bool StreamBegin::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StreamBegin::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StreamBegin::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StreamBegin::clear_domain() {
  if (domain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& StreamBegin::domain() const {
  // @@protoc_insertion_point(field_get:StreamBegin.domain)
  return *domain_;
}
inline void StreamBegin::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
  // @@protoc_insertion_point(field_set:StreamBegin.domain)
}
inline void StreamBegin::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
  // @@protoc_insertion_point(field_set_char:StreamBegin.domain)
}
inline void StreamBegin::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:StreamBegin.domain)
}
inline ::std::string* StreamBegin::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:StreamBegin.domain)
  return domain_;
}
inline ::std::string* StreamBegin::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StreamBegin::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:StreamBegin.domain)
}

// optional string version = 2;
inline bool StreamBegin::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StreamBegin::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StreamBegin::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StreamBegin::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& StreamBegin::version() const {
  // @@protoc_insertion_point(field_get:StreamBegin.version)
  return *version_;
}
inline void StreamBegin::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:StreamBegin.version)
}
inline void StreamBegin::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:StreamBegin.version)
}
inline void StreamBegin::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:StreamBegin.version)
}
inline ::std::string* StreamBegin::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:StreamBegin.version)
  return version_;
}
inline ::std::string* StreamBegin::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StreamBegin::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:StreamBegin.version)
}

// repeated .MessageBody bodys = 3;
inline int StreamBegin::bodys_size() const {
  return bodys_.size();
}
inline void StreamBegin::clear_bodys() {
  bodys_.Clear();
}
inline const ::MessageBody& StreamBegin::bodys(int index) const {
  // @@protoc_insertion_point(field_get:StreamBegin.bodys)
  return bodys_.Get(index);
}
inline ::MessageBody* StreamBegin::mutable_bodys(int index) {
  // @@protoc_insertion_point(field_mutable:StreamBegin.bodys)
  return bodys_.Mutable(index);
}
inline ::MessageBody* StreamBegin::add_bodys() {
  // @@protoc_insertion_point(field_add:StreamBegin.bodys)
  return bodys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MessageBody >&
StreamBegin::bodys() const {
  // @@protoc_insertion_point(field_list:StreamBegin.bodys)
  return bodys_;
}
inline ::google::protobuf::RepeatedPtrField< ::MessageBody >*
StreamBegin::mutable_bodys() {
  // @@protoc_insertion_point(field_mutable_list:StreamBegin.bodys)
  return &bodys_;
}

// -------------------------------------------------------------------

// StartTLS

// -------------------------------------------------------------------

// ProceedTLS

// -------------------------------------------------------------------

// StreamEnd

// optional string reason = 1;
inline bool StreamEnd::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StreamEnd::set_has_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StreamEnd::clear_has_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StreamEnd::clear_reason() {
  if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_->clear();
  }
  clear_has_reason();
}
inline const ::std::string& StreamEnd::reason() const {
  // @@protoc_insertion_point(field_get:StreamEnd.reason)
  return *reason_;
}
inline void StreamEnd::set_reason(const ::std::string& value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
  // @@protoc_insertion_point(field_set:StreamEnd.reason)
}
inline void StreamEnd::set_reason(const char* value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
  // @@protoc_insertion_point(field_set_char:StreamEnd.reason)
}
inline void StreamEnd::set_reason(const char* value, size_t size) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:StreamEnd.reason)
}
inline ::std::string* StreamEnd::mutable_reason() {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:StreamEnd.reason)
  return reason_;
}
inline ::std::string* StreamEnd::release_reason() {
  clear_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = reason_;
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StreamEnd::set_allocated_reason(::std::string* reason) {
  if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete reason_;
  }
  if (reason) {
    set_has_reason();
    reason_ = reason;
  } else {
    clear_has_reason();
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:StreamEnd.reason)
}

// optional int32 code = 2;
inline bool StreamEnd::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StreamEnd::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StreamEnd::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StreamEnd::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 StreamEnd::code() const {
  // @@protoc_insertion_point(field_get:StreamEnd.code)
  return code_;
}
inline void StreamEnd::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:StreamEnd.code)
}

// -------------------------------------------------------------------

// UserConnect

// optional string domain = 1;
inline bool UserConnect::has_domain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserConnect::set_has_domain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserConnect::clear_has_domain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserConnect::clear_domain() {
  if (domain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& UserConnect::domain() const {
  // @@protoc_insertion_point(field_get:UserConnect.domain)
  return *domain_;
}
inline void UserConnect::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
  // @@protoc_insertion_point(field_set:UserConnect.domain)
}
inline void UserConnect::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
  // @@protoc_insertion_point(field_set_char:UserConnect.domain)
}
inline void UserConnect::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UserConnect.domain)
}
inline ::std::string* UserConnect::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:UserConnect.domain)
  return domain_;
}
inline ::std::string* UserConnect::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserConnect::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:UserConnect.domain)
}

// optional string version = 2;
inline bool UserConnect::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserConnect::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserConnect::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserConnect::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& UserConnect::version() const {
  // @@protoc_insertion_point(field_get:UserConnect.version)
  return *version_;
}
inline void UserConnect::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:UserConnect.version)
}
inline void UserConnect::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:UserConnect.version)
}
inline void UserConnect::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:UserConnect.version)
}
inline ::std::string* UserConnect::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:UserConnect.version)
  return version_;
}
inline ::std::string* UserConnect::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserConnect::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:UserConnect.version)
}

// -------------------------------------------------------------------

// Capability

// optional string version = 1;
inline bool Capability::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Capability::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Capability::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Capability::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& Capability::version() const {
  // @@protoc_insertion_point(field_get:Capability.version)
  return *version_;
}
inline void Capability::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:Capability.version)
}
inline void Capability::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:Capability.version)
}
inline void Capability::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Capability.version)
}
inline ::std::string* Capability::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Capability.version)
  return version_;
}
inline ::std::string* Capability::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Capability::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Capability.version)
}

// optional .MessageBody bodys = 2;
inline bool Capability::has_bodys() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Capability::set_has_bodys() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Capability::clear_has_bodys() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Capability::clear_bodys() {
  if (bodys_ != NULL) bodys_->::MessageBody::Clear();
  clear_has_bodys();
}
inline const ::MessageBody& Capability::bodys() const {
  // @@protoc_insertion_point(field_get:Capability.bodys)
  return bodys_ != NULL ? *bodys_ : *default_instance_->bodys_;
}
inline ::MessageBody* Capability::mutable_bodys() {
  set_has_bodys();
  if (bodys_ == NULL) bodys_ = new ::MessageBody;
  // @@protoc_insertion_point(field_mutable:Capability.bodys)
  return bodys_;
}
inline ::MessageBody* Capability::release_bodys() {
  clear_has_bodys();
  ::MessageBody* temp = bodys_;
  bodys_ = NULL;
  return temp;
}
inline void Capability::set_allocated_bodys(::MessageBody* bodys) {
  delete bodys_;
  bodys_ = bodys;
  if (bodys) {
    set_has_bodys();
  } else {
    clear_has_bodys();
  }
  // @@protoc_insertion_point(field_set_allocated:Capability.bodys)
}

// -------------------------------------------------------------------

// ResponseSucceeded

// optional int32 code = 1;
inline bool ResponseSucceeded::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseSucceeded::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseSucceeded::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseSucceeded::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ResponseSucceeded::code() const {
  // @@protoc_insertion_point(field_get:ResponseSucceeded.code)
  return code_;
}
inline void ResponseSucceeded::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:ResponseSucceeded.code)
}

// optional string msgId = 2;
inline bool ResponseSucceeded::has_msgid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseSucceeded::set_has_msgid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseSucceeded::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseSucceeded::clear_msgid() {
  if (msgid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_->clear();
  }
  clear_has_msgid();
}
inline const ::std::string& ResponseSucceeded::msgid() const {
  // @@protoc_insertion_point(field_get:ResponseSucceeded.msgId)
  return *msgid_;
}
inline void ResponseSucceeded::set_msgid(const ::std::string& value) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
  // @@protoc_insertion_point(field_set:ResponseSucceeded.msgId)
}
inline void ResponseSucceeded::set_msgid(const char* value) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
  // @@protoc_insertion_point(field_set_char:ResponseSucceeded.msgId)
}
inline void ResponseSucceeded::set_msgid(const char* value, size_t size) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ResponseSucceeded.msgId)
}
inline ::std::string* ResponseSucceeded::mutable_msgid() {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ResponseSucceeded.msgId)
  return msgid_;
}
inline ::std::string* ResponseSucceeded::release_msgid() {
  clear_has_msgid();
  if (msgid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msgid_;
    msgid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ResponseSucceeded::set_allocated_msgid(::std::string* msgid) {
  if (msgid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msgid_;
  }
  if (msgid) {
    set_has_msgid();
    msgid_ = msgid;
  } else {
    clear_has_msgid();
    msgid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ResponseSucceeded.msgId)
}

// optional string info = 3;
inline bool ResponseSucceeded::has_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseSucceeded::set_has_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseSucceeded::clear_has_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseSucceeded::clear_info() {
  if (info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& ResponseSucceeded::info() const {
  // @@protoc_insertion_point(field_get:ResponseSucceeded.info)
  return *info_;
}
inline void ResponseSucceeded::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
  // @@protoc_insertion_point(field_set:ResponseSucceeded.info)
}
inline void ResponseSucceeded::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
  // @@protoc_insertion_point(field_set_char:ResponseSucceeded.info)
}
inline void ResponseSucceeded::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ResponseSucceeded.info)
}
inline ::std::string* ResponseSucceeded::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ResponseSucceeded.info)
  return info_;
}
inline ::std::string* ResponseSucceeded::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ResponseSucceeded::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ResponseSucceeded.info)
}

// optional .MessageBody body = 4;
inline bool ResponseSucceeded::has_body() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseSucceeded::set_has_body() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseSucceeded::clear_has_body() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseSucceeded::clear_body() {
  if (body_ != NULL) body_->::MessageBody::Clear();
  clear_has_body();
}
inline const ::MessageBody& ResponseSucceeded::body() const {
  // @@protoc_insertion_point(field_get:ResponseSucceeded.body)
  return body_ != NULL ? *body_ : *default_instance_->body_;
}
inline ::MessageBody* ResponseSucceeded::mutable_body() {
  set_has_body();
  if (body_ == NULL) body_ = new ::MessageBody;
  // @@protoc_insertion_point(field_mutable:ResponseSucceeded.body)
  return body_;
}
inline ::MessageBody* ResponseSucceeded::release_body() {
  clear_has_body();
  ::MessageBody* temp = body_;
  body_ = NULL;
  return temp;
}
inline void ResponseSucceeded::set_allocated_body(::MessageBody* body) {
  delete body_;
  body_ = body;
  if (body) {
    set_has_body();
  } else {
    clear_has_body();
  }
  // @@protoc_insertion_point(field_set_allocated:ResponseSucceeded.body)
}

// -------------------------------------------------------------------

// ResponseFailure

// optional int32 code = 1;
inline bool ResponseFailure::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseFailure::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseFailure::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseFailure::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ResponseFailure::code() const {
  // @@protoc_insertion_point(field_get:ResponseFailure.code)
  return code_;
}
inline void ResponseFailure::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:ResponseFailure.code)
}

// optional string msgId = 2;
inline bool ResponseFailure::has_msgid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseFailure::set_has_msgid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseFailure::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseFailure::clear_msgid() {
  if (msgid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_->clear();
  }
  clear_has_msgid();
}
inline const ::std::string& ResponseFailure::msgid() const {
  // @@protoc_insertion_point(field_get:ResponseFailure.msgId)
  return *msgid_;
}
inline void ResponseFailure::set_msgid(const ::std::string& value) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
  // @@protoc_insertion_point(field_set:ResponseFailure.msgId)
}
inline void ResponseFailure::set_msgid(const char* value) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
  // @@protoc_insertion_point(field_set_char:ResponseFailure.msgId)
}
inline void ResponseFailure::set_msgid(const char* value, size_t size) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ResponseFailure.msgId)
}
inline ::std::string* ResponseFailure::mutable_msgid() {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msgid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ResponseFailure.msgId)
  return msgid_;
}
inline ::std::string* ResponseFailure::release_msgid() {
  clear_has_msgid();
  if (msgid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msgid_;
    msgid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ResponseFailure::set_allocated_msgid(::std::string* msgid) {
  if (msgid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msgid_;
  }
  if (msgid) {
    set_has_msgid();
    msgid_ = msgid;
  } else {
    clear_has_msgid();
    msgid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ResponseFailure.msgId)
}

// optional string error = 3;
inline bool ResponseFailure::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseFailure::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseFailure::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseFailure::clear_error() {
  if (error_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& ResponseFailure::error() const {
  // @@protoc_insertion_point(field_get:ResponseFailure.error)
  return *error_;
}
inline void ResponseFailure::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(value);
  // @@protoc_insertion_point(field_set:ResponseFailure.error)
}
inline void ResponseFailure::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(value);
  // @@protoc_insertion_point(field_set_char:ResponseFailure.error)
}
inline void ResponseFailure::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ResponseFailure.error)
}
inline ::std::string* ResponseFailure::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ResponseFailure.error)
  return error_;
}
inline ::std::string* ResponseFailure::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ResponseFailure::set_allocated_error(::std::string* error) {
  if (error_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete error_;
  }
  if (error) {
    set_has_error();
    error_ = error;
  } else {
    clear_has_error();
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ResponseFailure.error)
}

// optional .MessageBody body = 4;
inline bool ResponseFailure::has_body() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseFailure::set_has_body() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseFailure::clear_has_body() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseFailure::clear_body() {
  if (body_ != NULL) body_->::MessageBody::Clear();
  clear_has_body();
}
inline const ::MessageBody& ResponseFailure::body() const {
  // @@protoc_insertion_point(field_get:ResponseFailure.body)
  return body_ != NULL ? *body_ : *default_instance_->body_;
}
inline ::MessageBody* ResponseFailure::mutable_body() {
  set_has_body();
  if (body_ == NULL) body_ = new ::MessageBody;
  // @@protoc_insertion_point(field_mutable:ResponseFailure.body)
  return body_;
}
inline ::MessageBody* ResponseFailure::release_body() {
  clear_has_body();
  ::MessageBody* temp = body_;
  body_ = NULL;
  return temp;
}
inline void ResponseFailure::set_allocated_body(::MessageBody* body) {
  delete body_;
  body_ = body;
  if (body) {
    set_has_body();
  } else {
    clear_has_body();
  }
  // @@protoc_insertion_point(field_set_allocated:ResponseFailure.body)
}

// -------------------------------------------------------------------

// ProtoMessage

// optional int32 options = 1;
inline bool ProtoMessage::has_options() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoMessage::set_has_options() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoMessage::clear_has_options() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoMessage::clear_options() {
  options_ = 0;
  clear_has_options();
}
inline ::google::protobuf::int32 ProtoMessage::options() const {
  // @@protoc_insertion_point(field_get:ProtoMessage.options)
  return options_;
}
inline void ProtoMessage::set_options(::google::protobuf::int32 value) {
  set_has_options();
  options_ = value;
  // @@protoc_insertion_point(field_set:ProtoMessage.options)
}

// required int32 signalType = 2 [default = 0];
inline bool ProtoMessage::has_signaltype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoMessage::set_has_signaltype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoMessage::clear_has_signaltype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoMessage::clear_signaltype() {
  signaltype_ = 0;
  clear_has_signaltype();
}
inline ::google::protobuf::int32 ProtoMessage::signaltype() const {
  // @@protoc_insertion_point(field_get:ProtoMessage.signalType)
  return signaltype_;
}
inline void ProtoMessage::set_signaltype(::google::protobuf::int32 value) {
  set_has_signaltype();
  signaltype_ = value;
  // @@protoc_insertion_point(field_set:ProtoMessage.signalType)
}

// optional string from = 3;
inline bool ProtoMessage::has_from() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoMessage::set_has_from() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoMessage::clear_has_from() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoMessage::clear_from() {
  if (from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& ProtoMessage::from() const {
  // @@protoc_insertion_point(field_get:ProtoMessage.from)
  return *from_;
}
inline void ProtoMessage::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_ = new ::std::string;
  }
  from_->assign(value);
  // @@protoc_insertion_point(field_set:ProtoMessage.from)
}
inline void ProtoMessage::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_ = new ::std::string;
  }
  from_->assign(value);
  // @@protoc_insertion_point(field_set_char:ProtoMessage.from)
}
inline void ProtoMessage::set_from(const char* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ProtoMessage.from)
}
inline ::std::string* ProtoMessage::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    from_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ProtoMessage.from)
  return from_;
}
inline ::std::string* ProtoMessage::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProtoMessage::set_allocated_from(::std::string* from) {
  if (from_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete from_;
  }
  if (from) {
    set_has_from();
    from_ = from;
  } else {
    clear_has_from();
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoMessage.from)
}

// optional string to = 4;
inline bool ProtoMessage::has_to() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoMessage::set_has_to() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoMessage::clear_has_to() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoMessage::clear_to() {
  if (to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_->clear();
  }
  clear_has_to();
}
inline const ::std::string& ProtoMessage::to() const {
  // @@protoc_insertion_point(field_get:ProtoMessage.to)
  return *to_;
}
inline void ProtoMessage::set_to(const ::std::string& value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_ = new ::std::string;
  }
  to_->assign(value);
  // @@protoc_insertion_point(field_set:ProtoMessage.to)
}
inline void ProtoMessage::set_to(const char* value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_ = new ::std::string;
  }
  to_->assign(value);
  // @@protoc_insertion_point(field_set_char:ProtoMessage.to)
}
inline void ProtoMessage::set_to(const char* value, size_t size) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_ = new ::std::string;
  }
  to_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ProtoMessage.to)
}
inline ::std::string* ProtoMessage::mutable_to() {
  set_has_to();
  if (to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    to_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ProtoMessage.to)
  return to_;
}
inline ::std::string* ProtoMessage::release_to() {
  clear_has_to();
  if (to_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = to_;
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProtoMessage::set_allocated_to(::std::string* to) {
  if (to_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete to_;
  }
  if (to) {
    set_has_to();
    to_ = to;
  } else {
    clear_has_to();
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoMessage.to)
}

// optional bytes message = 5;
inline bool ProtoMessage::has_message() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtoMessage::set_has_message() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtoMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtoMessage::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ProtoMessage::message() const {
  // @@protoc_insertion_point(field_get:ProtoMessage.message)
  return *message_;
}
inline void ProtoMessage::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:ProtoMessage.message)
}
inline void ProtoMessage::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:ProtoMessage.message)
}
inline void ProtoMessage::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ProtoMessage.message)
}
inline ::std::string* ProtoMessage::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ProtoMessage.message)
  return message_;
}
inline ::std::string* ProtoMessage::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProtoMessage::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoMessage.message)
}

// optional string realfrom = 6;
inline bool ProtoMessage::has_realfrom() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProtoMessage::set_has_realfrom() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProtoMessage::clear_has_realfrom() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProtoMessage::clear_realfrom() {
  if (realfrom_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    realfrom_->clear();
  }
  clear_has_realfrom();
}
inline const ::std::string& ProtoMessage::realfrom() const {
  // @@protoc_insertion_point(field_get:ProtoMessage.realfrom)
  return *realfrom_;
}
inline void ProtoMessage::set_realfrom(const ::std::string& value) {
  set_has_realfrom();
  if (realfrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    realfrom_ = new ::std::string;
  }
  realfrom_->assign(value);
  // @@protoc_insertion_point(field_set:ProtoMessage.realfrom)
}
inline void ProtoMessage::set_realfrom(const char* value) {
  set_has_realfrom();
  if (realfrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    realfrom_ = new ::std::string;
  }
  realfrom_->assign(value);
  // @@protoc_insertion_point(field_set_char:ProtoMessage.realfrom)
}
inline void ProtoMessage::set_realfrom(const char* value, size_t size) {
  set_has_realfrom();
  if (realfrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    realfrom_ = new ::std::string;
  }
  realfrom_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ProtoMessage.realfrom)
}
inline ::std::string* ProtoMessage::mutable_realfrom() {
  set_has_realfrom();
  if (realfrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    realfrom_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ProtoMessage.realfrom)
  return realfrom_;
}
inline ::std::string* ProtoMessage::release_realfrom() {
  clear_has_realfrom();
  if (realfrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = realfrom_;
    realfrom_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProtoMessage::set_allocated_realfrom(::std::string* realfrom) {
  if (realfrom_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete realfrom_;
  }
  if (realfrom) {
    set_has_realfrom();
    realfrom_ = realfrom;
  } else {
    clear_has_realfrom();
    realfrom_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoMessage.realfrom)
}

// optional string realto = 7;
inline bool ProtoMessage::has_realto() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProtoMessage::set_has_realto() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProtoMessage::clear_has_realto() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProtoMessage::clear_realto() {
  if (realto_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    realto_->clear();
  }
  clear_has_realto();
}
inline const ::std::string& ProtoMessage::realto() const {
  // @@protoc_insertion_point(field_get:ProtoMessage.realto)
  return *realto_;
}
inline void ProtoMessage::set_realto(const ::std::string& value) {
  set_has_realto();
  if (realto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    realto_ = new ::std::string;
  }
  realto_->assign(value);
  // @@protoc_insertion_point(field_set:ProtoMessage.realto)
}
inline void ProtoMessage::set_realto(const char* value) {
  set_has_realto();
  if (realto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    realto_ = new ::std::string;
  }
  realto_->assign(value);
  // @@protoc_insertion_point(field_set_char:ProtoMessage.realto)
}
inline void ProtoMessage::set_realto(const char* value, size_t size) {
  set_has_realto();
  if (realto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    realto_ = new ::std::string;
  }
  realto_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ProtoMessage.realto)
}
inline ::std::string* ProtoMessage::mutable_realto() {
  set_has_realto();
  if (realto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    realto_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ProtoMessage.realto)
  return realto_;
}
inline ::std::string* ProtoMessage::release_realto() {
  clear_has_realto();
  if (realto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = realto_;
    realto_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProtoMessage::set_allocated_realto(::std::string* realto) {
  if (realto_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete realto_;
  }
  if (realto) {
    set_has_realto();
    realto_ = realto;
  } else {
    clear_has_realto();
    realto_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoMessage.realto)
}

// optional string originfrom = 8;
inline bool ProtoMessage::has_originfrom() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ProtoMessage::set_has_originfrom() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ProtoMessage::clear_has_originfrom() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ProtoMessage::clear_originfrom() {
  if (originfrom_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    originfrom_->clear();
  }
  clear_has_originfrom();
}
inline const ::std::string& ProtoMessage::originfrom() const {
  // @@protoc_insertion_point(field_get:ProtoMessage.originfrom)
  return *originfrom_;
}
inline void ProtoMessage::set_originfrom(const ::std::string& value) {
  set_has_originfrom();
  if (originfrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    originfrom_ = new ::std::string;
  }
  originfrom_->assign(value);
  // @@protoc_insertion_point(field_set:ProtoMessage.originfrom)
}
inline void ProtoMessage::set_originfrom(const char* value) {
  set_has_originfrom();
  if (originfrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    originfrom_ = new ::std::string;
  }
  originfrom_->assign(value);
  // @@protoc_insertion_point(field_set_char:ProtoMessage.originfrom)
}
inline void ProtoMessage::set_originfrom(const char* value, size_t size) {
  set_has_originfrom();
  if (originfrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    originfrom_ = new ::std::string;
  }
  originfrom_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ProtoMessage.originfrom)
}
inline ::std::string* ProtoMessage::mutable_originfrom() {
  set_has_originfrom();
  if (originfrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    originfrom_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ProtoMessage.originfrom)
  return originfrom_;
}
inline ::std::string* ProtoMessage::release_originfrom() {
  clear_has_originfrom();
  if (originfrom_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = originfrom_;
    originfrom_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProtoMessage::set_allocated_originfrom(::std::string* originfrom) {
  if (originfrom_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete originfrom_;
  }
  if (originfrom) {
    set_has_originfrom();
    originfrom_ = originfrom;
  } else {
    clear_has_originfrom();
    originfrom_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoMessage.originfrom)
}

// optional string originto = 9;
inline bool ProtoMessage::has_originto() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ProtoMessage::set_has_originto() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ProtoMessage::clear_has_originto() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ProtoMessage::clear_originto() {
  if (originto_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    originto_->clear();
  }
  clear_has_originto();
}
inline const ::std::string& ProtoMessage::originto() const {
  // @@protoc_insertion_point(field_get:ProtoMessage.originto)
  return *originto_;
}
inline void ProtoMessage::set_originto(const ::std::string& value) {
  set_has_originto();
  if (originto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    originto_ = new ::std::string;
  }
  originto_->assign(value);
  // @@protoc_insertion_point(field_set:ProtoMessage.originto)
}
inline void ProtoMessage::set_originto(const char* value) {
  set_has_originto();
  if (originto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    originto_ = new ::std::string;
  }
  originto_->assign(value);
  // @@protoc_insertion_point(field_set_char:ProtoMessage.originto)
}
inline void ProtoMessage::set_originto(const char* value, size_t size) {
  set_has_originto();
  if (originto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    originto_ = new ::std::string;
  }
  originto_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ProtoMessage.originto)
}
inline ::std::string* ProtoMessage::mutable_originto() {
  set_has_originto();
  if (originto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    originto_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ProtoMessage.originto)
  return originto_;
}
inline ::std::string* ProtoMessage::release_originto() {
  clear_has_originto();
  if (originto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = originto_;
    originto_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProtoMessage::set_allocated_originto(::std::string* originto) {
  if (originto_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete originto_;
  }
  if (originto) {
    set_has_originto();
    originto_ = originto;
  } else {
    clear_has_originto();
    originto_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoMessage.originto)
}

// optional string origintype = 10;
inline bool ProtoMessage::has_origintype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ProtoMessage::set_has_origintype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ProtoMessage::clear_has_origintype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ProtoMessage::clear_origintype() {
  if (origintype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    origintype_->clear();
  }
  clear_has_origintype();
}
inline const ::std::string& ProtoMessage::origintype() const {
  // @@protoc_insertion_point(field_get:ProtoMessage.origintype)
  return *origintype_;
}
inline void ProtoMessage::set_origintype(const ::std::string& value) {
  set_has_origintype();
  if (origintype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    origintype_ = new ::std::string;
  }
  origintype_->assign(value);
  // @@protoc_insertion_point(field_set:ProtoMessage.origintype)
}
inline void ProtoMessage::set_origintype(const char* value) {
  set_has_origintype();
  if (origintype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    origintype_ = new ::std::string;
  }
  origintype_->assign(value);
  // @@protoc_insertion_point(field_set_char:ProtoMessage.origintype)
}
inline void ProtoMessage::set_origintype(const char* value, size_t size) {
  set_has_origintype();
  if (origintype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    origintype_ = new ::std::string;
  }
  origintype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ProtoMessage.origintype)
}
inline ::std::string* ProtoMessage::mutable_origintype() {
  set_has_origintype();
  if (origintype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    origintype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ProtoMessage.origintype)
  return origintype_;
}
inline ::std::string* ProtoMessage::release_origintype() {
  clear_has_origintype();
  if (origintype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = origintype_;
    origintype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProtoMessage::set_allocated_origintype(::std::string* origintype) {
  if (origintype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete origintype_;
  }
  if (origintype) {
    set_has_origintype();
    origintype_ = origintype;
  } else {
    clear_has_origintype();
    origintype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoMessage.origintype)
}

// optional string sendjid = 11;
inline bool ProtoMessage::has_sendjid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ProtoMessage::set_has_sendjid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ProtoMessage::clear_has_sendjid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ProtoMessage::clear_sendjid() {
  if (sendjid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sendjid_->clear();
  }
  clear_has_sendjid();
}
inline const ::std::string& ProtoMessage::sendjid() const {
  // @@protoc_insertion_point(field_get:ProtoMessage.sendjid)
  return *sendjid_;
}
inline void ProtoMessage::set_sendjid(const ::std::string& value) {
  set_has_sendjid();
  if (sendjid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sendjid_ = new ::std::string;
  }
  sendjid_->assign(value);
  // @@protoc_insertion_point(field_set:ProtoMessage.sendjid)
}
inline void ProtoMessage::set_sendjid(const char* value) {
  set_has_sendjid();
  if (sendjid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sendjid_ = new ::std::string;
  }
  sendjid_->assign(value);
  // @@protoc_insertion_point(field_set_char:ProtoMessage.sendjid)
}
inline void ProtoMessage::set_sendjid(const char* value, size_t size) {
  set_has_sendjid();
  if (sendjid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sendjid_ = new ::std::string;
  }
  sendjid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ProtoMessage.sendjid)
}
inline ::std::string* ProtoMessage::mutable_sendjid() {
  set_has_sendjid();
  if (sendjid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sendjid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ProtoMessage.sendjid)
  return sendjid_;
}
inline ::std::string* ProtoMessage::release_sendjid() {
  clear_has_sendjid();
  if (sendjid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sendjid_;
    sendjid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProtoMessage::set_allocated_sendjid(::std::string* sendjid) {
  if (sendjid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sendjid_;
  }
  if (sendjid) {
    set_has_sendjid();
    sendjid_ = sendjid;
  } else {
    clear_has_sendjid();
    sendjid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ProtoMessage.sendjid)
}

// -------------------------------------------------------------------

// MessageBody

// repeated .StringHeader headers = 1;
inline int MessageBody::headers_size() const {
  return headers_.size();
}
inline void MessageBody::clear_headers() {
  headers_.Clear();
}
inline const ::StringHeader& MessageBody::headers(int index) const {
  // @@protoc_insertion_point(field_get:MessageBody.headers)
  return headers_.Get(index);
}
inline ::StringHeader* MessageBody::mutable_headers(int index) {
  // @@protoc_insertion_point(field_mutable:MessageBody.headers)
  return headers_.Mutable(index);
}
inline ::StringHeader* MessageBody::add_headers() {
  // @@protoc_insertion_point(field_add:MessageBody.headers)
  return headers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::StringHeader >&
MessageBody::headers() const {
  // @@protoc_insertion_point(field_list:MessageBody.headers)
  return headers_;
}
inline ::google::protobuf::RepeatedPtrField< ::StringHeader >*
MessageBody::mutable_headers() {
  // @@protoc_insertion_point(field_mutable_list:MessageBody.headers)
  return &headers_;
}

// optional string value = 2;
inline bool MessageBody::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageBody::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageBody::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageBody::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& MessageBody::value() const {
  // @@protoc_insertion_point(field_get:MessageBody.value)
  return *value_;
}
inline void MessageBody::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:MessageBody.value)
}
inline void MessageBody::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:MessageBody.value)
}
inline void MessageBody::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MessageBody.value)
}
inline ::std::string* MessageBody::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:MessageBody.value)
  return value_;
}
inline ::std::string* MessageBody::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MessageBody::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:MessageBody.value)
}

// repeated .MessageBody bodys = 3;
inline int MessageBody::bodys_size() const {
  return bodys_.size();
}
inline void MessageBody::clear_bodys() {
  bodys_.Clear();
}
inline const ::MessageBody& MessageBody::bodys(int index) const {
  // @@protoc_insertion_point(field_get:MessageBody.bodys)
  return bodys_.Get(index);
}
inline ::MessageBody* MessageBody::mutable_bodys(int index) {
  // @@protoc_insertion_point(field_mutable:MessageBody.bodys)
  return bodys_.Mutable(index);
}
inline ::MessageBody* MessageBody::add_bodys() {
  // @@protoc_insertion_point(field_add:MessageBody.bodys)
  return bodys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MessageBody >&
MessageBody::bodys() const {
  // @@protoc_insertion_point(field_list:MessageBody.bodys)
  return bodys_;
}
inline ::google::protobuf::RepeatedPtrField< ::MessageBody >*
MessageBody::mutable_bodys() {
  // @@protoc_insertion_point(field_mutable_list:MessageBody.bodys)
  return &bodys_;
}

// -------------------------------------------------------------------

// IQMessage

// optional string namespace = 1;
inline bool IQMessage::has_namespace_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IQMessage::set_has_namespace_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IQMessage::clear_has_namespace_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IQMessage::clear_namespace_() {
  if (namespace__ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namespace__->clear();
  }
  clear_has_namespace_();
}
inline const ::std::string& IQMessage::namespace_() const {
  // @@protoc_insertion_point(field_get:IQMessage.namespace)
  return *namespace__;
}
inline void IQMessage::set_namespace_(const ::std::string& value) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(value);
  // @@protoc_insertion_point(field_set:IQMessage.namespace)
}
inline void IQMessage::set_namespace_(const char* value) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(value);
  // @@protoc_insertion_point(field_set_char:IQMessage.namespace)
}
inline void IQMessage::set_namespace_(const char* value, size_t size) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IQMessage.namespace)
}
inline ::std::string* IQMessage::mutable_namespace_() {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namespace__ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IQMessage.namespace)
  return namespace__;
}
inline ::std::string* IQMessage::release_namespace_() {
  clear_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = namespace__;
    namespace__ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IQMessage::set_allocated_namespace_(::std::string* namespace_) {
  if (namespace__ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete namespace__;
  }
  if (namespace_) {
    set_has_namespace_();
    namespace__ = namespace_;
  } else {
    clear_has_namespace_();
    namespace__ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IQMessage.namespace)
}

// optional string key = 2;
inline bool IQMessage::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IQMessage::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IQMessage::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IQMessage::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& IQMessage::key() const {
  // @@protoc_insertion_point(field_get:IQMessage.key)
  return *key_;
}
inline void IQMessage::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:IQMessage.key)
}
inline void IQMessage::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:IQMessage.key)
}
inline void IQMessage::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IQMessage.key)
}
inline ::std::string* IQMessage::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IQMessage.key)
  return key_;
}
inline ::std::string* IQMessage::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IQMessage::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IQMessage.key)
}

// optional string value = 3;
inline bool IQMessage::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IQMessage::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IQMessage::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IQMessage::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& IQMessage::value() const {
  // @@protoc_insertion_point(field_get:IQMessage.value)
  return *value_;
}
inline void IQMessage::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:IQMessage.value)
}
inline void IQMessage::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:IQMessage.value)
}
inline void IQMessage::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IQMessage.value)
}
inline ::std::string* IQMessage::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IQMessage.value)
  return value_;
}
inline ::std::string* IQMessage::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IQMessage::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IQMessage.value)
}

// optional string messageId = 4;
inline bool IQMessage::has_messageid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IQMessage::set_has_messageid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IQMessage::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IQMessage::clear_messageid() {
  if (messageid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messageid_->clear();
  }
  clear_has_messageid();
}
inline const ::std::string& IQMessage::messageid() const {
  // @@protoc_insertion_point(field_get:IQMessage.messageId)
  return *messageid_;
}
inline void IQMessage::set_messageid(const ::std::string& value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
  // @@protoc_insertion_point(field_set:IQMessage.messageId)
}
inline void IQMessage::set_messageid(const char* value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
  // @@protoc_insertion_point(field_set_char:IQMessage.messageId)
}
inline void IQMessage::set_messageid(const char* value, size_t size) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IQMessage.messageId)
}
inline ::std::string* IQMessage::mutable_messageid() {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messageid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IQMessage.messageId)
  return messageid_;
}
inline ::std::string* IQMessage::release_messageid() {
  clear_has_messageid();
  if (messageid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = messageid_;
    messageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IQMessage::set_allocated_messageid(::std::string* messageid) {
  if (messageid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete messageid_;
  }
  if (messageid) {
    set_has_messageid();
    messageid_ = messageid;
  } else {
    clear_has_messageid();
    messageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IQMessage.messageId)
}

// optional .StringHeader header = 5;
inline bool IQMessage::has_header() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IQMessage::set_has_header() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IQMessage::clear_has_header() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IQMessage::clear_header() {
  if (header_ != NULL) header_->::StringHeader::Clear();
  clear_has_header();
}
inline const ::StringHeader& IQMessage::header() const {
  // @@protoc_insertion_point(field_get:IQMessage.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::StringHeader* IQMessage::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::StringHeader;
  // @@protoc_insertion_point(field_mutable:IQMessage.header)
  return header_;
}
inline ::StringHeader* IQMessage::release_header() {
  clear_has_header();
  ::StringHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void IQMessage::set_allocated_header(::StringHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:IQMessage.header)
}

// optional .MessageBody body = 6;
inline bool IQMessage::has_body() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IQMessage::set_has_body() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IQMessage::clear_has_body() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IQMessage::clear_body() {
  if (body_ != NULL) body_->::MessageBody::Clear();
  clear_has_body();
}
inline const ::MessageBody& IQMessage::body() const {
  // @@protoc_insertion_point(field_get:IQMessage.body)
  return body_ != NULL ? *body_ : *default_instance_->body_;
}
inline ::MessageBody* IQMessage::mutable_body() {
  set_has_body();
  if (body_ == NULL) body_ = new ::MessageBody;
  // @@protoc_insertion_point(field_mutable:IQMessage.body)
  return body_;
}
inline ::MessageBody* IQMessage::release_body() {
  clear_has_body();
  ::MessageBody* temp = body_;
  body_ = NULL;
  return temp;
}
inline void IQMessage::set_allocated_body(::MessageBody* body) {
  delete body_;
  body_ = body;
  if (body) {
    set_has_body();
  } else {
    clear_has_body();
  }
  // @@protoc_insertion_point(field_set_allocated:IQMessage.body)
}

// optional int64 receivedTime = 7;
inline bool IQMessage::has_receivedtime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IQMessage::set_has_receivedtime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IQMessage::clear_has_receivedtime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IQMessage::clear_receivedtime() {
  receivedtime_ = GOOGLE_LONGLONG(0);
  clear_has_receivedtime();
}
inline ::google::protobuf::int64 IQMessage::receivedtime() const {
  // @@protoc_insertion_point(field_get:IQMessage.receivedTime)
  return receivedtime_;
}
inline void IQMessage::set_receivedtime(::google::protobuf::int64 value) {
  set_has_receivedtime();
  receivedtime_ = value;
  // @@protoc_insertion_point(field_set:IQMessage.receivedTime)
}

// optional int64 transferTime = 8;
inline bool IQMessage::has_transfertime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IQMessage::set_has_transfertime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IQMessage::clear_has_transfertime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IQMessage::clear_transfertime() {
  transfertime_ = GOOGLE_LONGLONG(0);
  clear_has_transfertime();
}
inline ::google::protobuf::int64 IQMessage::transfertime() const {
  // @@protoc_insertion_point(field_get:IQMessage.transferTime)
  return transfertime_;
}
inline void IQMessage::set_transfertime(::google::protobuf::int64 value) {
  set_has_transfertime();
  transfertime_ = value;
  // @@protoc_insertion_point(field_set:IQMessage.transferTime)
}

// repeated .StringHeader headers = 9;
inline int IQMessage::headers_size() const {
  return headers_.size();
}
inline void IQMessage::clear_headers() {
  headers_.Clear();
}
inline const ::StringHeader& IQMessage::headers(int index) const {
  // @@protoc_insertion_point(field_get:IQMessage.headers)
  return headers_.Get(index);
}
inline ::StringHeader* IQMessage::mutable_headers(int index) {
  // @@protoc_insertion_point(field_mutable:IQMessage.headers)
  return headers_.Mutable(index);
}
inline ::StringHeader* IQMessage::add_headers() {
  // @@protoc_insertion_point(field_add:IQMessage.headers)
  return headers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::StringHeader >&
IQMessage::headers() const {
  // @@protoc_insertion_point(field_list:IQMessage.headers)
  return headers_;
}
inline ::google::protobuf::RepeatedPtrField< ::StringHeader >*
IQMessage::mutable_headers() {
  // @@protoc_insertion_point(field_mutable_list:IQMessage.headers)
  return &headers_;
}

// repeated .MessageBody bodys = 10;
inline int IQMessage::bodys_size() const {
  return bodys_.size();
}
inline void IQMessage::clear_bodys() {
  bodys_.Clear();
}
inline const ::MessageBody& IQMessage::bodys(int index) const {
  // @@protoc_insertion_point(field_get:IQMessage.bodys)
  return bodys_.Get(index);
}
inline ::MessageBody* IQMessage::mutable_bodys(int index) {
  // @@protoc_insertion_point(field_mutable:IQMessage.bodys)
  return bodys_.Mutable(index);
}
inline ::MessageBody* IQMessage::add_bodys() {
  // @@protoc_insertion_point(field_add:IQMessage.bodys)
  return bodys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MessageBody >&
IQMessage::bodys() const {
  // @@protoc_insertion_point(field_list:IQMessage.bodys)
  return bodys_;
}
inline ::google::protobuf::RepeatedPtrField< ::MessageBody >*
IQMessage::mutable_bodys() {
  // @@protoc_insertion_point(field_mutable_list:IQMessage.bodys)
  return &bodys_;
}

// optional .IQMessageKeyType definedKey = 11;
inline bool IQMessage::has_definedkey() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void IQMessage::set_has_definedkey() {
  _has_bits_[0] |= 0x00000400u;
}
inline void IQMessage::clear_has_definedkey() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void IQMessage::clear_definedkey() {
  definedkey_ = 1;
  clear_has_definedkey();
}
inline ::IQMessageKeyType IQMessage::definedkey() const {
  // @@protoc_insertion_point(field_get:IQMessage.definedKey)
  return static_cast< ::IQMessageKeyType >(definedkey_);
}
inline void IQMessage::set_definedkey(::IQMessageKeyType value) {
  assert(::IQMessageKeyType_IsValid(value));
  set_has_definedkey();
  definedkey_ = value;
  // @@protoc_insertion_point(field_set:IQMessage.definedKey)
}

// -------------------------------------------------------------------

// PresenceMessage

// optional string namespace = 1;
inline bool PresenceMessage::has_namespace_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PresenceMessage::set_has_namespace_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PresenceMessage::clear_has_namespace_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PresenceMessage::clear_namespace_() {
  if (namespace__ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namespace__->clear();
  }
  clear_has_namespace_();
}
inline const ::std::string& PresenceMessage::namespace_() const {
  // @@protoc_insertion_point(field_get:PresenceMessage.namespace)
  return *namespace__;
}
inline void PresenceMessage::set_namespace_(const ::std::string& value) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(value);
  // @@protoc_insertion_point(field_set:PresenceMessage.namespace)
}
inline void PresenceMessage::set_namespace_(const char* value) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(value);
  // @@protoc_insertion_point(field_set_char:PresenceMessage.namespace)
}
inline void PresenceMessage::set_namespace_(const char* value, size_t size) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PresenceMessage.namespace)
}
inline ::std::string* PresenceMessage::mutable_namespace_() {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namespace__ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PresenceMessage.namespace)
  return namespace__;
}
inline ::std::string* PresenceMessage::release_namespace_() {
  clear_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = namespace__;
    namespace__ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PresenceMessage::set_allocated_namespace_(::std::string* namespace_) {
  if (namespace__ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete namespace__;
  }
  if (namespace_) {
    set_has_namespace_();
    namespace__ = namespace_;
  } else {
    clear_has_namespace_();
    namespace__ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PresenceMessage.namespace)
}

// optional string key = 2;
inline bool PresenceMessage::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PresenceMessage::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PresenceMessage::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PresenceMessage::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& PresenceMessage::key() const {
  // @@protoc_insertion_point(field_get:PresenceMessage.key)
  return *key_;
}
inline void PresenceMessage::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:PresenceMessage.key)
}
inline void PresenceMessage::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:PresenceMessage.key)
}
inline void PresenceMessage::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PresenceMessage.key)
}
inline ::std::string* PresenceMessage::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PresenceMessage.key)
  return key_;
}
inline ::std::string* PresenceMessage::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PresenceMessage::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PresenceMessage.key)
}

// optional string value = 3;
inline bool PresenceMessage::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PresenceMessage::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PresenceMessage::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PresenceMessage::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& PresenceMessage::value() const {
  // @@protoc_insertion_point(field_get:PresenceMessage.value)
  return *value_;
}
inline void PresenceMessage::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:PresenceMessage.value)
}
inline void PresenceMessage::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:PresenceMessage.value)
}
inline void PresenceMessage::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PresenceMessage.value)
}
inline ::std::string* PresenceMessage::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PresenceMessage.value)
  return value_;
}
inline ::std::string* PresenceMessage::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PresenceMessage::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PresenceMessage.value)
}

// optional string messageId = 4;
inline bool PresenceMessage::has_messageid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PresenceMessage::set_has_messageid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PresenceMessage::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PresenceMessage::clear_messageid() {
  if (messageid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messageid_->clear();
  }
  clear_has_messageid();
}
inline const ::std::string& PresenceMessage::messageid() const {
  // @@protoc_insertion_point(field_get:PresenceMessage.messageId)
  return *messageid_;
}
inline void PresenceMessage::set_messageid(const ::std::string& value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
  // @@protoc_insertion_point(field_set:PresenceMessage.messageId)
}
inline void PresenceMessage::set_messageid(const char* value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
  // @@protoc_insertion_point(field_set_char:PresenceMessage.messageId)
}
inline void PresenceMessage::set_messageid(const char* value, size_t size) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PresenceMessage.messageId)
}
inline ::std::string* PresenceMessage::mutable_messageid() {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messageid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PresenceMessage.messageId)
  return messageid_;
}
inline ::std::string* PresenceMessage::release_messageid() {
  clear_has_messageid();
  if (messageid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = messageid_;
    messageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PresenceMessage::set_allocated_messageid(::std::string* messageid) {
  if (messageid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete messageid_;
  }
  if (messageid) {
    set_has_messageid();
    messageid_ = messageid;
  } else {
    clear_has_messageid();
    messageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PresenceMessage.messageId)
}

// optional .StringHeader header = 5;
inline bool PresenceMessage::has_header() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PresenceMessage::set_has_header() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PresenceMessage::clear_has_header() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PresenceMessage::clear_header() {
  if (header_ != NULL) header_->::StringHeader::Clear();
  clear_has_header();
}
inline const ::StringHeader& PresenceMessage::header() const {
  // @@protoc_insertion_point(field_get:PresenceMessage.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::StringHeader* PresenceMessage::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::StringHeader;
  // @@protoc_insertion_point(field_mutable:PresenceMessage.header)
  return header_;
}
inline ::StringHeader* PresenceMessage::release_header() {
  clear_has_header();
  ::StringHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void PresenceMessage::set_allocated_header(::StringHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:PresenceMessage.header)
}

// optional .MessageBody body = 6;
inline bool PresenceMessage::has_body() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PresenceMessage::set_has_body() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PresenceMessage::clear_has_body() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PresenceMessage::clear_body() {
  if (body_ != NULL) body_->::MessageBody::Clear();
  clear_has_body();
}
inline const ::MessageBody& PresenceMessage::body() const {
  // @@protoc_insertion_point(field_get:PresenceMessage.body)
  return body_ != NULL ? *body_ : *default_instance_->body_;
}
inline ::MessageBody* PresenceMessage::mutable_body() {
  set_has_body();
  if (body_ == NULL) body_ = new ::MessageBody;
  // @@protoc_insertion_point(field_mutable:PresenceMessage.body)
  return body_;
}
inline ::MessageBody* PresenceMessage::release_body() {
  clear_has_body();
  ::MessageBody* temp = body_;
  body_ = NULL;
  return temp;
}
inline void PresenceMessage::set_allocated_body(::MessageBody* body) {
  delete body_;
  body_ = body;
  if (body) {
    set_has_body();
  } else {
    clear_has_body();
  }
  // @@protoc_insertion_point(field_set_allocated:PresenceMessage.body)
}

// optional int64 receivedTime = 7;
inline bool PresenceMessage::has_receivedtime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PresenceMessage::set_has_receivedtime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PresenceMessage::clear_has_receivedtime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PresenceMessage::clear_receivedtime() {
  receivedtime_ = GOOGLE_LONGLONG(0);
  clear_has_receivedtime();
}
inline ::google::protobuf::int64 PresenceMessage::receivedtime() const {
  // @@protoc_insertion_point(field_get:PresenceMessage.receivedTime)
  return receivedtime_;
}
inline void PresenceMessage::set_receivedtime(::google::protobuf::int64 value) {
  set_has_receivedtime();
  receivedtime_ = value;
  // @@protoc_insertion_point(field_set:PresenceMessage.receivedTime)
}

// optional int64 transferTime = 8;
inline bool PresenceMessage::has_transfertime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PresenceMessage::set_has_transfertime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PresenceMessage::clear_has_transfertime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PresenceMessage::clear_transfertime() {
  transfertime_ = GOOGLE_LONGLONG(0);
  clear_has_transfertime();
}
inline ::google::protobuf::int64 PresenceMessage::transfertime() const {
  // @@protoc_insertion_point(field_get:PresenceMessage.transferTime)
  return transfertime_;
}
inline void PresenceMessage::set_transfertime(::google::protobuf::int64 value) {
  set_has_transfertime();
  transfertime_ = value;
  // @@protoc_insertion_point(field_set:PresenceMessage.transferTime)
}

// repeated .StringHeader headers = 9;
inline int PresenceMessage::headers_size() const {
  return headers_.size();
}
inline void PresenceMessage::clear_headers() {
  headers_.Clear();
}
inline const ::StringHeader& PresenceMessage::headers(int index) const {
  // @@protoc_insertion_point(field_get:PresenceMessage.headers)
  return headers_.Get(index);
}
inline ::StringHeader* PresenceMessage::mutable_headers(int index) {
  // @@protoc_insertion_point(field_mutable:PresenceMessage.headers)
  return headers_.Mutable(index);
}
inline ::StringHeader* PresenceMessage::add_headers() {
  // @@protoc_insertion_point(field_add:PresenceMessage.headers)
  return headers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::StringHeader >&
PresenceMessage::headers() const {
  // @@protoc_insertion_point(field_list:PresenceMessage.headers)
  return headers_;
}
inline ::google::protobuf::RepeatedPtrField< ::StringHeader >*
PresenceMessage::mutable_headers() {
  // @@protoc_insertion_point(field_mutable_list:PresenceMessage.headers)
  return &headers_;
}

// repeated .MessageBody bodys = 10;
inline int PresenceMessage::bodys_size() const {
  return bodys_.size();
}
inline void PresenceMessage::clear_bodys() {
  bodys_.Clear();
}
inline const ::MessageBody& PresenceMessage::bodys(int index) const {
  // @@protoc_insertion_point(field_get:PresenceMessage.bodys)
  return bodys_.Get(index);
}
inline ::MessageBody* PresenceMessage::mutable_bodys(int index) {
  // @@protoc_insertion_point(field_mutable:PresenceMessage.bodys)
  return bodys_.Mutable(index);
}
inline ::MessageBody* PresenceMessage::add_bodys() {
  // @@protoc_insertion_point(field_add:PresenceMessage.bodys)
  return bodys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MessageBody >&
PresenceMessage::bodys() const {
  // @@protoc_insertion_point(field_list:PresenceMessage.bodys)
  return bodys_;
}
inline ::google::protobuf::RepeatedPtrField< ::MessageBody >*
PresenceMessage::mutable_bodys() {
  // @@protoc_insertion_point(field_mutable_list:PresenceMessage.bodys)
  return &bodys_;
}

// optional .PresenceKeyType definedKey = 11;
inline bool PresenceMessage::has_definedkey() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PresenceMessage::set_has_definedkey() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PresenceMessage::clear_has_definedkey() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PresenceMessage::clear_definedkey() {
  definedkey_ = 1;
  clear_has_definedkey();
}
inline ::PresenceKeyType PresenceMessage::definedkey() const {
  // @@protoc_insertion_point(field_get:PresenceMessage.definedKey)
  return static_cast< ::PresenceKeyType >(definedkey_);
}
inline void PresenceMessage::set_definedkey(::PresenceKeyType value) {
  assert(::PresenceKeyType_IsValid(value));
  set_has_definedkey();
  definedkey_ = value;
  // @@protoc_insertion_point(field_set:PresenceMessage.definedKey)
}

// optional int32 categoryType = 12;
inline bool PresenceMessage::has_categorytype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PresenceMessage::set_has_categorytype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PresenceMessage::clear_has_categorytype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PresenceMessage::clear_categorytype() {
  categorytype_ = 0;
  clear_has_categorytype();
}
inline ::google::protobuf::int32 PresenceMessage::categorytype() const {
  // @@protoc_insertion_point(field_get:PresenceMessage.categoryType)
  return categorytype_;
}
inline void PresenceMessage::set_categorytype(::google::protobuf::int32 value) {
  set_has_categorytype();
  categorytype_ = value;
  // @@protoc_insertion_point(field_set:PresenceMessage.categoryType)
}

// -------------------------------------------------------------------

// XmppMessage

// required int32 messageType = 1 [default = 0];
inline bool XmppMessage::has_messagetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XmppMessage::set_has_messagetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XmppMessage::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XmppMessage::clear_messagetype() {
  messagetype_ = 0;
  clear_has_messagetype();
}
inline ::google::protobuf::int32 XmppMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:XmppMessage.messageType)
  return messagetype_;
}
inline void XmppMessage::set_messagetype(::google::protobuf::int32 value) {
  set_has_messagetype();
  messagetype_ = value;
  // @@protoc_insertion_point(field_set:XmppMessage.messageType)
}

// required int32 clientType = 2 [default = 0];
inline bool XmppMessage::has_clienttype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XmppMessage::set_has_clienttype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XmppMessage::clear_has_clienttype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XmppMessage::clear_clienttype() {
  clienttype_ = 0;
  clear_has_clienttype();
}
inline ::google::protobuf::int32 XmppMessage::clienttype() const {
  // @@protoc_insertion_point(field_get:XmppMessage.clientType)
  return clienttype_;
}
inline void XmppMessage::set_clienttype(::google::protobuf::int32 value) {
  set_has_clienttype();
  clienttype_ = value;
  // @@protoc_insertion_point(field_set:XmppMessage.clientType)
}

// required int64 clientVersion = 3;
inline bool XmppMessage::has_clientversion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void XmppMessage::set_has_clientversion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void XmppMessage::clear_has_clientversion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void XmppMessage::clear_clientversion() {
  clientversion_ = GOOGLE_LONGLONG(0);
  clear_has_clientversion();
}
inline ::google::protobuf::int64 XmppMessage::clientversion() const {
  // @@protoc_insertion_point(field_get:XmppMessage.clientVersion)
  return clientversion_;
}
inline void XmppMessage::set_clientversion(::google::protobuf::int64 value) {
  set_has_clientversion();
  clientversion_ = value;
  // @@protoc_insertion_point(field_set:XmppMessage.clientVersion)
}

// optional string namespace = 4;
inline bool XmppMessage::has_namespace_() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void XmppMessage::set_has_namespace_() {
  _has_bits_[0] |= 0x00000008u;
}
inline void XmppMessage::clear_has_namespace_() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void XmppMessage::clear_namespace_() {
  if (namespace__ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namespace__->clear();
  }
  clear_has_namespace_();
}
inline const ::std::string& XmppMessage::namespace_() const {
  // @@protoc_insertion_point(field_get:XmppMessage.namespace)
  return *namespace__;
}
inline void XmppMessage::set_namespace_(const ::std::string& value) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(value);
  // @@protoc_insertion_point(field_set:XmppMessage.namespace)
}
inline void XmppMessage::set_namespace_(const char* value) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(value);
  // @@protoc_insertion_point(field_set_char:XmppMessage.namespace)
}
inline void XmppMessage::set_namespace_(const char* value, size_t size) {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namespace__ = new ::std::string;
  }
  namespace__->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:XmppMessage.namespace)
}
inline ::std::string* XmppMessage::mutable_namespace_() {
  set_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namespace__ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:XmppMessage.namespace)
  return namespace__;
}
inline ::std::string* XmppMessage::release_namespace_() {
  clear_has_namespace_();
  if (namespace__ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = namespace__;
    namespace__ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void XmppMessage::set_allocated_namespace_(::std::string* namespace_) {
  if (namespace__ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete namespace__;
  }
  if (namespace_) {
    set_has_namespace_();
    namespace__ = namespace_;
  } else {
    clear_has_namespace_();
    namespace__ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:XmppMessage.namespace)
}

// optional string key = 5;
inline bool XmppMessage::has_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void XmppMessage::set_has_key() {
  _has_bits_[0] |= 0x00000010u;
}
inline void XmppMessage::clear_has_key() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void XmppMessage::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& XmppMessage::key() const {
  // @@protoc_insertion_point(field_get:XmppMessage.key)
  return *key_;
}
inline void XmppMessage::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:XmppMessage.key)
}
inline void XmppMessage::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:XmppMessage.key)
}
inline void XmppMessage::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:XmppMessage.key)
}
inline ::std::string* XmppMessage::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:XmppMessage.key)
  return key_;
}
inline ::std::string* XmppMessage::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void XmppMessage::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:XmppMessage.key)
}

// optional string value = 6;
inline bool XmppMessage::has_value() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void XmppMessage::set_has_value() {
  _has_bits_[0] |= 0x00000020u;
}
inline void XmppMessage::clear_has_value() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void XmppMessage::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& XmppMessage::value() const {
  // @@protoc_insertion_point(field_get:XmppMessage.value)
  return *value_;
}
inline void XmppMessage::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:XmppMessage.value)
}
inline void XmppMessage::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:XmppMessage.value)
}
inline void XmppMessage::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:XmppMessage.value)
}
inline ::std::string* XmppMessage::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:XmppMessage.value)
  return value_;
}
inline ::std::string* XmppMessage::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void XmppMessage::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:XmppMessage.value)
}

// optional string messageId = 7;
inline bool XmppMessage::has_messageid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void XmppMessage::set_has_messageid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void XmppMessage::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void XmppMessage::clear_messageid() {
  if (messageid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messageid_->clear();
  }
  clear_has_messageid();
}
inline const ::std::string& XmppMessage::messageid() const {
  // @@protoc_insertion_point(field_get:XmppMessage.messageId)
  return *messageid_;
}
inline void XmppMessage::set_messageid(const ::std::string& value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
  // @@protoc_insertion_point(field_set:XmppMessage.messageId)
}
inline void XmppMessage::set_messageid(const char* value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
  // @@protoc_insertion_point(field_set_char:XmppMessage.messageId)
}
inline void XmppMessage::set_messageid(const char* value, size_t size) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:XmppMessage.messageId)
}
inline ::std::string* XmppMessage::mutable_messageid() {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messageid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:XmppMessage.messageId)
  return messageid_;
}
inline ::std::string* XmppMessage::release_messageid() {
  clear_has_messageid();
  if (messageid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = messageid_;
    messageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void XmppMessage::set_allocated_messageid(::std::string* messageid) {
  if (messageid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete messageid_;
  }
  if (messageid) {
    set_has_messageid();
    messageid_ = messageid;
  } else {
    clear_has_messageid();
    messageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:XmppMessage.messageId)
}

// optional .StringHeader header = 8;
inline bool XmppMessage::has_header() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void XmppMessage::set_has_header() {
  _has_bits_[0] |= 0x00000080u;
}
inline void XmppMessage::clear_has_header() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void XmppMessage::clear_header() {
  if (header_ != NULL) header_->::StringHeader::Clear();
  clear_has_header();
}
inline const ::StringHeader& XmppMessage::header() const {
  // @@protoc_insertion_point(field_get:XmppMessage.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::StringHeader* XmppMessage::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::StringHeader;
  // @@protoc_insertion_point(field_mutable:XmppMessage.header)
  return header_;
}
inline ::StringHeader* XmppMessage::release_header() {
  clear_has_header();
  ::StringHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void XmppMessage::set_allocated_header(::StringHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:XmppMessage.header)
}

// optional .MessageBody body = 9;
inline bool XmppMessage::has_body() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void XmppMessage::set_has_body() {
  _has_bits_[0] |= 0x00000100u;
}
inline void XmppMessage::clear_has_body() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void XmppMessage::clear_body() {
  if (body_ != NULL) body_->::MessageBody::Clear();
  clear_has_body();
}
inline const ::MessageBody& XmppMessage::body() const {
  // @@protoc_insertion_point(field_get:XmppMessage.body)
  return body_ != NULL ? *body_ : *default_instance_->body_;
}
inline ::MessageBody* XmppMessage::mutable_body() {
  set_has_body();
  if (body_ == NULL) body_ = new ::MessageBody;
  // @@protoc_insertion_point(field_mutable:XmppMessage.body)
  return body_;
}
inline ::MessageBody* XmppMessage::release_body() {
  clear_has_body();
  ::MessageBody* temp = body_;
  body_ = NULL;
  return temp;
}
inline void XmppMessage::set_allocated_body(::MessageBody* body) {
  delete body_;
  body_ = body;
  if (body) {
    set_has_body();
  } else {
    clear_has_body();
  }
  // @@protoc_insertion_point(field_set_allocated:XmppMessage.body)
}

// optional int64 receivedTime = 10;
inline bool XmppMessage::has_receivedtime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void XmppMessage::set_has_receivedtime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void XmppMessage::clear_has_receivedtime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void XmppMessage::clear_receivedtime() {
  receivedtime_ = GOOGLE_LONGLONG(0);
  clear_has_receivedtime();
}
inline ::google::protobuf::int64 XmppMessage::receivedtime() const {
  // @@protoc_insertion_point(field_get:XmppMessage.receivedTime)
  return receivedtime_;
}
inline void XmppMessage::set_receivedtime(::google::protobuf::int64 value) {
  set_has_receivedtime();
  receivedtime_ = value;
  // @@protoc_insertion_point(field_set:XmppMessage.receivedTime)
}

// optional int64 transferTime = 11;
inline bool XmppMessage::has_transfertime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void XmppMessage::set_has_transfertime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void XmppMessage::clear_has_transfertime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void XmppMessage::clear_transfertime() {
  transfertime_ = GOOGLE_LONGLONG(0);
  clear_has_transfertime();
}
inline ::google::protobuf::int64 XmppMessage::transfertime() const {
  // @@protoc_insertion_point(field_get:XmppMessage.transferTime)
  return transfertime_;
}
inline void XmppMessage::set_transfertime(::google::protobuf::int64 value) {
  set_has_transfertime();
  transfertime_ = value;
  // @@protoc_insertion_point(field_set:XmppMessage.transferTime)
}

// repeated .StringHeader headers = 12;
inline int XmppMessage::headers_size() const {
  return headers_.size();
}
inline void XmppMessage::clear_headers() {
  headers_.Clear();
}
inline const ::StringHeader& XmppMessage::headers(int index) const {
  // @@protoc_insertion_point(field_get:XmppMessage.headers)
  return headers_.Get(index);
}
inline ::StringHeader* XmppMessage::mutable_headers(int index) {
  // @@protoc_insertion_point(field_mutable:XmppMessage.headers)
  return headers_.Mutable(index);
}
inline ::StringHeader* XmppMessage::add_headers() {
  // @@protoc_insertion_point(field_add:XmppMessage.headers)
  return headers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::StringHeader >&
XmppMessage::headers() const {
  // @@protoc_insertion_point(field_list:XmppMessage.headers)
  return headers_;
}
inline ::google::protobuf::RepeatedPtrField< ::StringHeader >*
XmppMessage::mutable_headers() {
  // @@protoc_insertion_point(field_mutable_list:XmppMessage.headers)
  return &headers_;
}

// repeated .MessageBody bodys = 13;
inline int XmppMessage::bodys_size() const {
  return bodys_.size();
}
inline void XmppMessage::clear_bodys() {
  bodys_.Clear();
}
inline const ::MessageBody& XmppMessage::bodys(int index) const {
  // @@protoc_insertion_point(field_get:XmppMessage.bodys)
  return bodys_.Get(index);
}
inline ::MessageBody* XmppMessage::mutable_bodys(int index) {
  // @@protoc_insertion_point(field_mutable:XmppMessage.bodys)
  return bodys_.Mutable(index);
}
inline ::MessageBody* XmppMessage::add_bodys() {
  // @@protoc_insertion_point(field_add:XmppMessage.bodys)
  return bodys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MessageBody >&
XmppMessage::bodys() const {
  // @@protoc_insertion_point(field_list:XmppMessage.bodys)
  return bodys_;
}
inline ::google::protobuf::RepeatedPtrField< ::MessageBody >*
XmppMessage::mutable_bodys() {
  // @@protoc_insertion_point(field_mutable_list:XmppMessage.bodys)
  return &bodys_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::SignalType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SignalType>() {
  return ::SignalType_descriptor();
}
template <> struct is_proto_enum< ::ClientType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ClientType>() {
  return ::ClientType_descriptor();
}
template <> struct is_proto_enum< ::MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MessageType>() {
  return ::MessageType_descriptor();
}
template <> struct is_proto_enum< ::StringHeaderType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::StringHeaderType>() {
  return ::StringHeaderType_descriptor();
}
template <> struct is_proto_enum< ::IQMessageKeyType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IQMessageKeyType>() {
  return ::IQMessageKeyType_descriptor();
}
template <> struct is_proto_enum< ::StreamEndCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::StreamEndCode>() {
  return ::StreamEndCode_descriptor();
}
template <> struct is_proto_enum< ::CategoryType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CategoryType>() {
  return ::CategoryType_descriptor();
}
template <> struct is_proto_enum< ::PresenceKeyType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PresenceKeyType>() {
  return ::PresenceKeyType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
